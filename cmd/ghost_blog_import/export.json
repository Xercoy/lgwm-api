{"db":[{"meta":{"exported_on":1467682437516,"version":"005"},"data":{"posts":[{"id":2,"uuid":"7c3f5622-bc04-4f0b-90a1-d3f099ec6b89","title":"First Post!","slug":"first-post","markdown":"Hi! Took a while to get things going, but it's finally up.\n\nFor now, learngowith.me will be a series of random content that I find useful in my adventures of learning Go. **You can expect to see a new post every week.**\n\nIt will most likely benefit new Gophers at first since I'm just as new. I'd like this website to have organized examples while the blog will have accompanying writeups and updates. \n\n~~On the short term I will be working on adding support for comments~~. Looking forward to input of the Go community that will promote learning and inspiration.\n\nLastly, please feel free to send me an email for feedback. Input for recommended content is appreciated. \n","html":"<p>Hi! Took a while to get things going, but it's finally up.</p>\n\n<p>For now, learngowith.me will be a series of random content that I find useful in my adventures of learning Go. <strong>You can expect to see a new post every week.</strong></p>\n\n<p>It will most likely benefit new Gophers at first since I'm just as new. I'd like this website to have organized examples while the blog will have accompanying writeups and updates. </p>\n\n<p><del>On the short term I will be working on adding support for comments</del>. Looking forward to input of the Go community that will promote learning and inspiration.</p>\n\n<p>Lastly, please feel free to send me an email for feedback. Input for recommended content is appreciated. </p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1402847102771,"created_by":1,"updated_at":1404588997233,"updated_by":1,"published_at":1402847102773,"published_by":1,"visibility":"public","mobiledoc":null},{"id":3,"uuid":"4ea5de31-e4a5-4841-b64b-d45d89a13b09","title":"Notes on Go's Slice Data Type","slug":"notes-on-slices","markdown":"**This post will mostly be helpful if you're new to slices in Go.**\n\nWhen it comes to understanding slices, Andrew Gerrand's post [Go Slices: usage and internals](http://blog.golang.org/go-slices-usage-and-internals) is always brought up. It's very useful and I've referred to it myself multiple times. However, nothing helps more than practice. Instead of exlpaining in great detail what they are, I thought I'd share additional information that may be useful to others who may be new to slices or need a refresher. \n\nFirst off, I'd like to mention a slice's implementation from [runtime.h](http://golang.org/src/pkg/runtime/runtime.h), which is in C:\n\n\tstruct\tSlice\n\t{\t\t\t\t // must not move anything\n\t\tbyte*\tarray; // actual data\n\t\tuintgo\tlen;   // number of elements\n\t\tuintgo\tcap;   // allocated number of elements\n\t};\n    \nRecall that a `byte` is an unsigned, 8 bit integer, while `uintgo` is an unsigned integer (32 or 64 depending on your architecture). The `array` field of a slice simply stores an address.\n\nThe `len` field will indicate the size of the current slice of an array.\n\n`cap` indicates the size of the array that the `array` field points to. \n\n\n####Default Values\nThe value of an empty slice is nil while len() and cap() will return a value of 0.\n\n####Passing Slices By Name\nOne of the most fundamental details to remember is the concept of passing by reference and passing by value. \n\nWhen a slice is passed by name, the three fields of a slice (the header) are the values that are copied from and assigned to. \n\nAlthough the values of the header are passed by value, the value of the `array` field is an address. With that said, I contend:\n\n> The headers of a slice are passed by value. The underlying array that the `array` field points to is passed by reference.\n\nWhat does this mean? Well, the data of the underlying array is passed by reference because the address is what is copied. When the underlying array is modified, the array field of a slice is obviously unchanged. \n\nThe remaining headers are not pointers, so their values must be updated when the slice is manipulated + there is a desire for the changes to persist. Consider this:\n\n[copying_slices.go](https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/notes_on_slices/copying_slices.go)\n**(For brevity, output statements excluded below.)**\n```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n        intSlice := []int{1, 2, 3}\n\n        secondIntSlice := intSlice\n\n        secondIntSlice[0] = 9\n\n\t\tsecondIntSlice = secondIntSlice[0:1]\n}\n```\n\n#####Output\n```\nintSlice:[1 2 3]\n\nsecondIntSlice[0] = 9.\n\nsecondIntSlice:[9 2 3]\n\nintSlice:[9 2 3]\n\nsliced secondIntSlice to [0,1].\n\nsecondIntSlice:[9]\n\nintSlice - len:3 cap:3\n\nsecondIntSlice - len:1 cap:3\n```\n\n#####Explanation\n\nWe create a slice `intSlice` which will refer to an integer array with three elements. \n\nThen a second slice is declared, `secondIntSlice`, in which `intSlice` is assigned to it, copying the values of the headers over. \n\nThe program modifies `secondIntSlice[0]` and prints `intSlice` to demonstrate that their `data` fields are pointing to the same array.\n\n`secondIntSlice` is then sliced to demonstrate its headers being updated. \n\n#####In Memory\nHere's a vague example of what things look like under the hood, the address is abitrary:\n\n[copying\\_slices\\_image.go](https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/notes_on_slices/copying_slices_image.jpg)\n\n<img src=\"https://raw.githubusercontent.com/Xercoy/LearnGoWithMe-Code/master/notes_on_slices/copying_slices_image.jpg\">\n\n####A Little More...\n\nThis blog post was inspired by a Gopher on [/r/golang](http://www.reddit.com/r/golang) who was having some trouble with slices. This person had wanted to write a function that would \"fill out\" a struct, which had a field of type slice, when one was passed to it. [Here's](http://http://www.reddit.com/r/golang/comments/283vpk/help_with_slices_and_passbyreference/) the post.\n\n>I've been trying to pass a slice of a struct to a function in order to get filled with contents. ... I'm not pasing it with pointers, just like a plain variable... I return to the caller function but the array is still empty, even when data was added at the called function.\n\nTo replicate this, here's [use\\_case\\_problem.go](https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/notes_on_slices/use_case_problem.go) **(For brevity, output statements excluded below.)**:\n```\npackage main\n\nimport \"fmt\"\n\ntype Foo struct {\n\tintSlice []int\n}\n\nfunc Fill(f Foo, newValue int) {\n\tf.intSlice = append(f.intSlice, newValue)\n}\n\nfunc main() {\n\tvar customType Foo\n\n\tFill(FooVariable, 12)\n}\n```\n\n#####OUTPUT\n```\nmain - FooVariable.intSlice:[]\nmain - Executing Fill(FooVariable, 12)\nFill - Executing append(f.intSlice, newValue)\nFill - f.intSlice:[12]\nmain - FooVariable.intSlice:[]\n```\n\nAs you can see, `FooVariable` is empty in main before and after the `Fill` function was called. \n\nIn the `Fill` function, the `append` function takes care of allocating space for an integer (if there isn't space already) and assigns the value of the integer variable `newValue` to the particular element. \n\n`append` returns a slice in which its header values are then assigned to the local variable `f`. \n\nThe newly appended value of 12 is present since `f`'s header values were updated `append`, yet isn't present in `FooVariable` because its headers never change.\n\n####The solution? Update the headers.\n\nOne way of achieving the desired functionality is to create a function that will return a slice. An assignment could be made to a slice from the returned value, effectively updating the slice headers. This is how the `append()` function works. For example:\n\n[slice_example.go](https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/notes_on_slices/slice_example.go)\n```\npackage main\n\nimport \"fmt\"\n\nfunc intSliceHandler(intSlice []int, newValue int) []int {\n        return append(intSlice, newValue)\n}\n\nfunc main() {\n        var intSlice []int\n\n        fmt.Printf(\"\\nmain - intSlice:%v\\n\", intSlice)\n\n        intSlice = intSliceHandler(intSlice, 5)\n\n        fmt.Printf(\"\\nmain - intSlice after intSliceHandler():%v\\n\\n\", intSlice)\n}\n```\n#####OUTPUT\n```\nmain - intSlice:[]\n\nmain - intSlice after intSliceHandler():[5]\n```\n\nAnother method of populating a slice would be to preallocate the space and simply have a function populate the next element with the new value. Again, the header of the slice (`len` field) would need to be updated to reflect the new addition. \n\n####Thoughts and Other Comments\n- Slices are tricky, but with practice you'll be fine. \n\n- Returning the address of a local variable is fine. The space will persist.","html":"<p><strong>This post will mostly be helpful if you're new to slices in Go.</strong></p>\n\n<p>When it comes to understanding slices, Andrew Gerrand's post <a href=\"http://blog.golang.org/go-slices-usage-and-internals\">Go Slices: usage and internals</a> is always brought up. It's very useful and I've referred to it myself multiple times. However, nothing helps more than practice. Instead of exlpaining in great detail what they are, I thought I'd share additional information that may be useful to others who may be new to slices or need a refresher. </p>\n\n<p>First off, I'd like to mention a slice's implementation from <a href=\"http://golang.org/src/pkg/runtime/runtime.h\">runtime.h</a>, which is in C:</p>\n\n<pre><code>struct  Slice\n{                // must not move anything\n    byte*   array; // actual data\n    uintgo  len;   // number of elements\n    uintgo  cap;   // allocated number of elements\n};\n</code></pre>\n\n<p>Recall that a <code>byte</code> is an unsigned, 8 bit integer, while <code>uintgo</code> is an unsigned integer (32 or 64 depending on your architecture). The <code>array</code> field of a slice simply stores an address.</p>\n\n<p>The <code>len</code> field will indicate the size of the current slice of an array.</p>\n\n<p><code>cap</code> indicates the size of the array that the <code>array</code> field points to. </p>\n\n<h4 id=\"defaultvalues\">Default Values</h4>\n\n<p>The value of an empty slice is nil while len() and cap() will return a value of 0.</p>\n\n<h4 id=\"passingslicesbyname\">Passing Slices By Name</h4>\n\n<p>One of the most fundamental details to remember is the concept of passing by reference and passing by value. </p>\n\n<p>When a slice is passed by name, the three fields of a slice (the header) are the values that are copied from and assigned to. </p>\n\n<p>Although the values of the header are passed by value, the value of the <code>array</code> field is an address. With that said, I contend:</p>\n\n<blockquote>\n  <p>The headers of a slice are passed by value. The underlying array that the <code>array</code> field points to is passed by reference.</p>\n</blockquote>\n\n<p>What does this mean? Well, the data of the underlying array is passed by reference because the address is what is copied. When the underlying array is modified, the array field of a slice is obviously unchanged. </p>\n\n<p>The remaining headers are not pointers, so their values must be updated when the slice is manipulated + there is a desire for the changes to persist. Consider this:</p>\n\n<p><a href=\"https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/notes_on_slices/copying_slices.go\">copying_slices.go</a>\n<strong>(For brevity, output statements excluded below.)</strong></p>\n\n<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n        intSlice := []int{1, 2, 3}\n\n        secondIntSlice := intSlice\n\n        secondIntSlice[0] = 9\n\n        secondIntSlice = secondIntSlice[0:1]\n}\n</code></pre>\n\n<h5 id=\"output\">Output</h5>\n\n<pre><code>intSlice:[1 2 3]\n\nsecondIntSlice[0] = 9.\n\nsecondIntSlice:[9 2 3]\n\nintSlice:[9 2 3]\n\nsliced secondIntSlice to [0,1].\n\nsecondIntSlice:[9]\n\nintSlice - len:3 cap:3\n\nsecondIntSlice - len:1 cap:3  \n</code></pre>\n\n<h5 id=\"explanation\">Explanation</h5>\n\n<p>We create a slice <code>intSlice</code> which will refer to an integer array with three elements. </p>\n\n<p>Then a second slice is declared, <code>secondIntSlice</code>, in which <code>intSlice</code> is assigned to it, copying the values of the headers over. </p>\n\n<p>The program modifies <code>secondIntSlice[0]</code> and prints <code>intSlice</code> to demonstrate that their <code>data</code> fields are pointing to the same array.</p>\n\n<p><code>secondIntSlice</code> is then sliced to demonstrate its headers being updated. </p>\n\n<h5 id=\"inmemory\">In Memory</h5>\n\n<p>Here's a vague example of what things look like under the hood, the address is abitrary:</p>\n\n<p><a href=\"https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/notes_on_slices/copying_slices_image.jpg\">copying_slices_image.go</a></p>\n\n<p><img src=\"https://raw.githubusercontent.com/Xercoy/LearnGoWithMe-Code/master/notes_on_slices/copying_slices_image.jpg\"></p>\n\n<h4 id=\"alittlemore\">A Little More...</h4>\n\n<p>This blog post was inspired by a Gopher on <a href=\"http://www.reddit.com/r/golang\">/r/golang</a> who was having some trouble with slices. This person had wanted to write a function that would \"fill out\" a struct, which had a field of type slice, when one was passed to it. <a href=\"http://http://www.reddit.com/r/golang/comments/283vpk/help_with_slices_and_passbyreference/\">Here's</a> the post.</p>\n\n<blockquote>\n  <p>I've been trying to pass a slice of a struct to a function in order to get filled with contents. ... I'm not pasing it with pointers, just like a plain variable... I return to the caller function but the array is still empty, even when data was added at the called function.</p>\n</blockquote>\n\n<p>To replicate this, here's <a href=\"https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/notes_on_slices/use_case_problem.go\">use_case_problem.go</a> <strong>(For brevity, output statements excluded below.)</strong>:  </p>\n\n<pre><code>package main\n\nimport \"fmt\"\n\ntype Foo struct {  \n    intSlice []int\n}\n\nfunc Fill(f Foo, newValue int) {  \n    f.intSlice = append(f.intSlice, newValue)\n}\n\nfunc main() {  \n    var customType Foo\n\n    Fill(FooVariable, 12)\n}\n</code></pre>\n\n<h5 id=\"output\">OUTPUT</h5>\n\n<pre><code>main - FooVariable.intSlice:[]  \nmain - Executing Fill(FooVariable, 12)  \nFill - Executing append(f.intSlice, newValue)  \nFill - f.intSlice:[12]  \nmain - FooVariable.intSlice:[]  \n</code></pre>\n\n<p>As you can see, <code>FooVariable</code> is empty in main before and after the <code>Fill</code> function was called. </p>\n\n<p>In the <code>Fill</code> function, the <code>append</code> function takes care of allocating space for an integer (if there isn't space already) and assigns the value of the integer variable <code>newValue</code> to the particular element. </p>\n\n<p><code>append</code> returns a slice in which its header values are then assigned to the local variable <code>f</code>. </p>\n\n<p>The newly appended value of 12 is present since <code>f</code>'s header values were updated <code>append</code>, yet isn't present in <code>FooVariable</code> because its headers never change.</p>\n\n<h4 id=\"thesolutionupdatetheheaders\">The solution? Update the headers.</h4>\n\n<p>One way of achieving the desired functionality is to create a function that will return a slice. An assignment could be made to a slice from the returned value, effectively updating the slice headers. This is how the <code>append()</code> function works. For example:</p>\n\n<p><a href=\"https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/notes_on_slices/slice_example.go\">slice_example.go</a></p>\n\n<pre><code>package main\n\nimport \"fmt\"\n\nfunc intSliceHandler(intSlice []int, newValue int) []int {  \n        return append(intSlice, newValue)\n}\n\nfunc main() {  \n        var intSlice []int\n\n        fmt.Printf(\"\\nmain - intSlice:%v\\n\", intSlice)\n\n        intSlice = intSliceHandler(intSlice, 5)\n\n        fmt.Printf(\"\\nmain - intSlice after intSliceHandler():%v\\n\\n\", intSlice)\n}\n</code></pre>\n\n<h5 id=\"output\">OUTPUT</h5>\n\n<pre><code>main - intSlice:[]\n\nmain - intSlice after intSliceHandler():[5]  \n</code></pre>\n\n<p>Another method of populating a slice would be to preallocate the space and simply have a function populate the next element with the new value. Again, the header of the slice (<code>len</code> field) would need to be updated to reflect the new addition. </p>\n\n<h4 id=\"thoughtsandothercomments\">Thoughts and Other Comments</h4>\n\n<ul>\n<li><p>Slices are tricky, but with practice you'll be fine. </p></li>\n<li><p>Returning the address of a local variable is fine. The space will persist.</p></li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1402862033803,"created_by":1,"updated_at":1407871103448,"updated_by":1,"published_at":1407037901919,"published_by":1,"visibility":"public","mobiledoc":null},{"id":4,"uuid":"3eb52551-6ee1-4167-b626-05871536cbae","title":"Bubble Sort","slug":"bubble-sort","markdown":"\n####EDIT (06/05/2014): \n\n- Code in this post is now available [here](https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/bubble_sort/bubble_sort.go) as a single, executable file. \n\n- Added a section to this post containing code to test the bubble sort algorithm.\n\n---\n\nHere's my implementation of bubble sort in Go. This wasn't so much a whim as it was more just refreshing my algorithms knowledge.\n\nI thought I was being slick by using slices to iterate through the number array, but it was somewhat confusing. I just would have liked to try something specific to Go instead of simple pointers. Formatted for readability. Anyways:\n\n    func bubbleSort(slice []int) {\n\t  \n      for end := (len(slice) - 1); end >= 0; end-- {\n       \n        for iteratingSlice := slice;    \n        &iteratingSlice[0] != &slice[end];  \n        iteratingSlice = iteratingSlice[1:] {\n          \n          if iteratingSlice[0] > iteratingSlice[1] {\n            elementHolder := iteratingSlice[0]\n            iteratingSlice[0] = iteratingSlice[1]\n            iteratingSlice[1] = elementHolder\n          } //Close if block\n          \n        } //Close inner for loop\n\t  } //Close outer for loop\n    } //Closing function brace\n##Analysis\n####Outer for loop\n    for end := (len(slice) - 1); end >= 0; end-- {\n        /* other code */\n    }\nThis for loop makes use of an integer variable `end`. End will initially refer to the last cell and move one cell at a time from right to left until it reaches the first cell. \n\nThe inner loop will need access to every element, starting at the first cell and \\`bubble\\` up the largest value to the right. Since the element at the end of each iteration is guaranteed to be sorted, the inner loop doesn't need to do anything with that element anymore. We make the inner loop ignore it by reducing end, thus shortening the length of the slice to kind of \\`hide\\` it.  \n    \n####Inner for loop\n    for iteratingSlice := slice;    \n        &iteratingSlice[0] != &slice[end];  \n        iteratingSlice = iteratingSlice[1:] {\n        /* other code */\n    }    \n`iteratingSlice` initially copies the header values from slice. \n\nAt each iteration, iteratingSlice is sliced to refer to a smaller portion of itself. The expression iteratingSlice[1:] refers to the second element of the slice to the end. This way, by \"truncating\" the first cell, we're slowly moving up the array from left to right. Remember that nothing is actually truncated, the slice as a whole is still intact, we're only changing the portion that iteratingSlice is referring to.\n\nThe loop exits when the address of the first cell of iteratingSlice is the equivalent to the address of the cell that end is currently referring to. This indicates that the iteration is completed. \n\n####If block\n    if iteratingSlice[0] > iteratingSlice[1] {\n            elementHolder := iteratingSlice[0]\n            iteratingSlice[0] = iteratingSlice[1]\n            iteratingSlice[1] = elementHolder\n          } //Close if block\nThis is probably the easiest part. We're only comparing two cells. If the value of the first cell is greater than the value of the second cell, swap them. We make use of a variable to temporarily hold a value as the cells are being swapped. \n\n##Testing the Algorithm\nThe following code was used to test the algorithm. \n```\nfunc main() {\n\tnumberSlice := []int{1, 4, 6, 8, 7, 9, 3, 5, 2}\n\n\tfmt.Printf(\"\\nMain, unsorted integer array: %v\\n\", numberSlice)\n\n\tSort(numberSlice)\n\n\tfmt.Printf(\"\\nMain, sorted integer array: %v\\n\\n\", numberSlice)\n}\n```\n\n####Output\n```\nMain, unsorted integer array: [1 4 6 8 7 9 3 5 2]\n\nMain, sorted integer array: [1 2 3 4 5 6 7 8 9]\n```\n\n##Conclusion\nHope this was easy to follow, please feel free to make any suggestions or corrections. In further implementations I will attempt to provide tests. I also may decide to have each algorithm return a status to completment error handling...","html":"<h4 id=\"edit06052014\">EDIT (06/05/2014):</h4>\n\n<ul>\n<li><p>Code in this post is now available <a href=\"https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/bubble_sort/bubble_sort.go\">here</a> as a single, executable file. </p></li>\n<li><p>Added a section to this post containing code to test the bubble sort algorithm.</p></li>\n</ul>\n\n<hr />\n\n<p>Here's my implementation of bubble sort in Go. This wasn't so much a whim as it was more just refreshing my algorithms knowledge.</p>\n\n<p>I thought I was being slick by using slices to iterate through the number array, but it was somewhat confusing. I just would have liked to try something specific to Go instead of simple pointers. Formatted for readability. Anyways:</p>\n\n<pre><code>func bubbleSort(slice []int) {\n\n  for end := (len(slice) - 1); end &gt;= 0; end-- {\n\n    for iteratingSlice := slice;    \n    &amp;iteratingSlice[0] != &amp;slice[end];  \n    iteratingSlice = iteratingSlice[1:] {\n\n      if iteratingSlice[0] &gt; iteratingSlice[1] {\n        elementHolder := iteratingSlice[0]\n        iteratingSlice[0] = iteratingSlice[1]\n        iteratingSlice[1] = elementHolder\n      } //Close if block\n\n    } //Close inner for loop\n  } //Close outer for loop\n} //Closing function brace\n</code></pre>\n\n<h2 id=\"analysis\">Analysis</h2>\n\n<h4 id=\"outerforloop\">Outer for loop</h4>\n\n<pre><code>for end := (len(slice) - 1); end &gt;= 0; end-- {\n    /* other code */\n}\n</code></pre>\n\n<p>This for loop makes use of an integer variable <code>end</code>. End will initially refer to the last cell and move one cell at a time from right to left until it reaches the first cell. </p>\n\n<p>The inner loop will need access to every element, starting at the first cell and `bubble` up the largest value to the right. Since the element at the end of each iteration is guaranteed to be sorted, the inner loop doesn't need to do anything with that element anymore. We make the inner loop ignore it by reducing end, thus shortening the length of the slice to kind of `hide` it.  </p>\n\n<h4 id=\"innerforloop\">Inner for loop</h4>\n\n<pre><code>for iteratingSlice := slice;    \n    &amp;iteratingSlice[0] != &amp;slice[end];  \n    iteratingSlice = iteratingSlice[1:] {\n    /* other code */\n}    \n</code></pre>\n\n<p><code>iteratingSlice</code> initially copies the header values from slice. </p>\n\n<p>At each iteration, iteratingSlice is sliced to refer to a smaller portion of itself. The expression iteratingSlice[1:] refers to the second element of the slice to the end. This way, by \"truncating\" the first cell, we're slowly moving up the array from left to right. Remember that nothing is actually truncated, the slice as a whole is still intact, we're only changing the portion that iteratingSlice is referring to.</p>\n\n<p>The loop exits when the address of the first cell of iteratingSlice is the equivalent to the address of the cell that end is currently referring to. This indicates that the iteration is completed. </p>\n\n<h4 id=\"ifblock\">If block</h4>\n\n<pre><code>if iteratingSlice[0] &gt; iteratingSlice[1] {\n        elementHolder := iteratingSlice[0]\n        iteratingSlice[0] = iteratingSlice[1]\n        iteratingSlice[1] = elementHolder\n      } //Close if block\n</code></pre>\n\n<p>This is probably the easiest part. We're only comparing two cells. If the value of the first cell is greater than the value of the second cell, swap them. We make use of a variable to temporarily hold a value as the cells are being swapped. </p>\n\n<h2 id=\"testingthealgorithm\">Testing the Algorithm</h2>\n\n<p>The following code was used to test the algorithm.  </p>\n\n<pre><code>func main() {  \n    numberSlice := []int{1, 4, 6, 8, 7, 9, 3, 5, 2}\n\n    fmt.Printf(\"\\nMain, unsorted integer array: %v\\n\", numberSlice)\n\n    Sort(numberSlice)\n\n    fmt.Printf(\"\\nMain, sorted integer array: %v\\n\\n\", numberSlice)\n}\n</code></pre>\n\n<h4 id=\"output\">Output</h4>\n\n<pre><code>Main, unsorted integer array: [1 4 6 8 7 9 3 5 2]\n\nMain, sorted integer array: [1 2 3 4 5 6 7 8 9]  \n</code></pre>\n\n<h2 id=\"conclusion\">Conclusion</h2>\n\n<p>Hope this was easy to follow, please feel free to make any suggestions or corrections. In further implementations I will attempt to provide tests. I also may decide to have each algorithm return a status to completment error handling...</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1403581104459,"created_by":1,"updated_at":1404603059242,"updated_by":1,"published_at":1403581104463,"published_by":1,"visibility":"public","mobiledoc":null},{"id":5,"uuid":"9dc51c45-b8f6-4126-8321-746515b6f2c7","title":"A Quine in Go","slug":"quine","markdown":"<br>\n###tl;dr [Quines]((http://en.wikipedia.org/wiki/Quine_(computing)) are cool. Create one and [share yours](https://github.com/Xercoy/quines)!\n\nBefore I slept last night, I read a post on /r/golang that invited people to [post their own version of the famous fizzbuzz program](http://www.reddit.com/r/golang/comments/28xwt1/fun_with_fizzbuzz_post_your_own/). Many of them put [mine](http://play.golang.org/p/4sLBFuuDxF) to shame, there were people did some fancy things.\n\nInstead of creating a version of fizzbuzz in Go with my own flare, I recalled a past homework assignment where I had to create a Quine in Go. From [Wikipedia](http://en.wikipedia.org/wiki/Quine_(computing)), \n> \"A quine is a computer program which takes no input and produces a copy of its own source code as its only output.\" \n\nHere's my one liner (explanation included later):\n\n    package main;import\"fmt\";func main(){s:=`package main;import\"fmt\";func main(){s:=%c%s%c;fmt.Printf(s,96,s,96)}`;fmt.Printf(s,96,s,96)}\n\nAlthough its pretty basic and adopted from a sample C version, I enjoyed writing it. Even more giddy to see the creative things that other people can come up with, and created a [Github Repo](https://github.com/Xercoy/quines/tree/go) for people to contribute and share their Quines in Go, Ruby, C, whatever.\n\n###Create your own\nHelpful resources : \n\n-[Quines](http://www.madore.org/~david/computers/quine.html) By David Madore, A very thorough resource with examples and explanations. \n\n-[The Quine Page](http://www.nyx.net/~gthompso/quine.htm) By Gary P. Thompson II, Quines of varying implementations \n\n###Explanation of my Quine\n(skip for final thoughts)\n\n    package main;import\"fmt\";func main(){s:=`package main;import\"fmt\";func main(){s:=%c%s%c;fmt.Printf(s,96,s,96)}`;fmt.Printf(s,96,s,96)}\n\nI wanted to make it as compact and simple as possible, hence the semicolons (I'm sorry fellow Gophers) so that I could place every statement on one line.\n\nNotice that the main function only has two statements, a declaration of a string literal  s, and a call to the Printf function of the fmt package. \n\nThe magic is in the second statement, `fmt.Printf(s,96,s,96)`. As usual, the first argument to Printf is a string that contains format specifiers (%c, %s, %c, respectively). The next three arguments satisfy values that the format specifiers require. 96 is the ASCII decimal equivalent of the backtick character. \n\nNow that we have that out of the way, let's step through the output made by Printf, substituting one format specifier at a time: \n\n####The String n\n    package main;import\"fmt\";func main(){s:=%c%s%c;fmt.Printf(s,96,s,96)}\n    \n####Substituting the first format specifier %c\n    package main;import\"fmt\";func main(){s:=`%s%c;fmt.Printf(s,96,s,96)}    \n\n####Substituting the second format specifier %s\n    package main;import\"fmt\";func main(){s:=`package main;import\"fmt\";func main(){s:=%c%s%c;fmt.Printf(s,96,s,96)}%c;fmt.Printf(s,96,s,96)}\n####Substituting the last format specifier %c\n    package main;import\"fmt\";func main(){s:=`package main;import\"fmt\";func main(){s:=%c%s%c;fmt.Printf(s,96,s,96)}`;fmt.Printf(s,96,s,96)}\n\nAnd that's about it! Again, there are Quines out there that make this implementation seem like child's play. I recommend viewing those for drawing the greatest inspiration. \n\n###Final Thoughts and Comments\n- I originally wanted to make a repository strictly of quines in Go, but did not want to limit contributors to the repo. I instead opted to create branches by language.\n\n- Feedback is always appreciated. Also, if you've found any resources that you'd like to share, let me know!\n\n- A concurrent Quine would be epic, huh?\n","html":"<p><br>  </p>\n\n<h3 id=\"tldrquineshttpenwikipediaorgwikiquine_computingarecoolcreateoneandshareyourshttpsgithubcomxercoyquines\">tl;dr <a href=\"(http://en.wikipedia.org/wiki/Quine_(computing)\">Quines</a> are cool. Create one and <a href=\"https://github.com/Xercoy/quines\">share yours</a>!</h3>\n\n<p>Before I slept last night, I read a post on /r/golang that invited people to <a href=\"http://www.reddit.com/r/golang/comments/28xwt1/fun_with_fizzbuzz_post_your_own/\">post their own version of the famous fizzbuzz program</a>. Many of them put <a href=\"http://play.golang.org/p/4sLBFuuDxF\">mine</a> to shame, there were people did some fancy things.</p>\n\n<p>Instead of creating a version of fizzbuzz in Go with my own flare, I recalled a past homework assignment where I had to create a Quine in Go. From <a href=\"http://en.wikipedia.org/wiki/Quine_(computing)\">Wikipedia</a>,  </p>\n\n<blockquote>\n  <p>\"A quine is a computer program which takes no input and produces a copy of its own source code as its only output.\" </p>\n</blockquote>\n\n<p>Here's my one liner (explanation included later):</p>\n\n<pre><code>package main;import\"fmt\";func main(){s:=`package main;import\"fmt\";func main(){s:=%c%s%c;fmt.Printf(s,96,s,96)}`;fmt.Printf(s,96,s,96)}\n</code></pre>\n\n<p>Although its pretty basic and adopted from a sample C version, I enjoyed writing it. Even more giddy to see the creative things that other people can come up with, and created a <a href=\"https://github.com/Xercoy/quines/tree/go\">Github Repo</a> for people to contribute and share their Quines in Go, Ruby, C, whatever.</p>\n\n<h3 id=\"createyourown\">Create your own</h3>\n\n<p>Helpful resources : </p>\n\n<p>-<a href=\"http://www.madore.org/~david/computers/quine.html\">Quines</a> By David Madore, A very thorough resource with examples and explanations. </p>\n\n<p>-<a href=\"http://www.nyx.net/~gthompso/quine.htm\">The Quine Page</a> By Gary P. Thompson II, Quines of varying implementations </p>\n\n<h3 id=\"explanationofmyquine\">Explanation of my Quine</h3>\n\n<p>(skip for final thoughts)</p>\n\n<pre><code>package main;import\"fmt\";func main(){s:=`package main;import\"fmt\";func main(){s:=%c%s%c;fmt.Printf(s,96,s,96)}`;fmt.Printf(s,96,s,96)}\n</code></pre>\n\n<p>I wanted to make it as compact and simple as possible, hence the semicolons (I'm sorry fellow Gophers) so that I could place every statement on one line.</p>\n\n<p>Notice that the main function only has two statements, a declaration of a string literal  s, and a call to the Printf function of the fmt package. </p>\n\n<p>The magic is in the second statement, <code>fmt.Printf(s,96,s,96)</code>. As usual, the first argument to Printf is a string that contains format specifiers (%c, %s, %c, respectively). The next three arguments satisfy values that the format specifiers require. 96 is the ASCII decimal equivalent of the backtick character. </p>\n\n<p>Now that we have that out of the way, let's step through the output made by Printf, substituting one format specifier at a time: </p>\n\n<h4 id=\"thestringn\">The String n</h4>\n\n<pre><code>package main;import\"fmt\";func main(){s:=%c%s%c;fmt.Printf(s,96,s,96)}\n</code></pre>\n\n<h4 id=\"substitutingthefirstformatspecifierc\">Substituting the first format specifier %c</h4>\n\n<pre><code>package main;import\"fmt\";func main(){s:=`%s%c;fmt.Printf(s,96,s,96)}    \n</code></pre>\n\n<h4 id=\"substitutingthesecondformatspecifiers\">Substituting the second format specifier %s</h4>\n\n<pre><code>package main;import\"fmt\";func main(){s:=`package main;import\"fmt\";func main(){s:=%c%s%c;fmt.Printf(s,96,s,96)}%c;fmt.Printf(s,96,s,96)}\n</code></pre>\n\n<h4 id=\"substitutingthelastformatspecifierc\">Substituting the last format specifier %c</h4>\n\n<pre><code>package main;import\"fmt\";func main(){s:=`package main;import\"fmt\";func main(){s:=%c%s%c;fmt.Printf(s,96,s,96)}`;fmt.Printf(s,96,s,96)}\n</code></pre>\n\n<p>And that's about it! Again, there are Quines out there that make this implementation seem like child's play. I recommend viewing those for drawing the greatest inspiration. </p>\n\n<h3 id=\"finalthoughtsandcomments\">Final Thoughts and Comments</h3>\n\n<ul>\n<li><p>I originally wanted to make a repository strictly of quines in Go, but did not want to limit contributors to the repo. I instead opted to create branches by language.</p></li>\n<li><p>Feedback is always appreciated. Also, if you've found any resources that you'd like to share, let me know!</p></li>\n<li><p>A concurrent Quine would be epic, huh?</p></li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1403649994939,"created_by":1,"updated_at":1403874300871,"updated_by":1,"published_at":1403662668425,"published_by":1,"visibility":"public","mobiledoc":null},{"id":6,"uuid":"fdebcbc8-04ae-4547-beef-92bcd7220670","title":"Insertion Sort with an Empty Interface and Tests","slug":"insertion-sort-and-empty-interfaces","markdown":"If you're not familiar with insertion sort, I recommend [this](https://www.youtube.com/watch?v=ROalU379l3U) awesome four minute video which depicts insertion sort in Romanian folk dance. \n\nThis implementation of a polymorphic insertion sort strengthened my understanding of interfaces in Go, and finally gave me the chance to write some tests. The whole process went through a good number of rewrites and ended up being very similar to the official Go sort package's implementation.\n\nThe type of slice used is an empty interface so that any type could be supported. \n\nThere are two main files to this writeup that compliment each other:\n\n- insertionSort.go, contains core implementation.\n- main.go, describes sample usage.  \n\nAll code can be found at [this](https://github.com/Xercoy/Go-Data-Structures-and-Algorithms) Github repo.\n\n##InsertionSort.go\n\n    //insertionSort.go\n\n    package sort\n\n\tfunc InsertionSort(data Interface) {\n\t\tfor i := 0; i < data.Len(); i++ {\n\t\t\tfor j := i; j > 0 && data.Less(j, j-1); j-- {\n\t\t\t\tdata.Swap(j, j-1)\n\t\t\t}\n\t\t}\n\t}\n\n\ttype Interface interface {\n\t\tLen() int\n\t\tLess(x int, y int) bool\n\t\tSwap(x int, y int)\n\t}\n\n\n\n##Explanation of insertionSort.go\nThe magic of `insertionSort` is in the interface. Once we have a named type that implements the interface, we can pass it to `insertionSort\t` which will take care of the rest through use of the methods implemented from the interface.\n\nOnce that's understood, the rest of `insertionSort` is fairly simple. \n\nThe first for loop iterates through each cell of a slice from left to right: \n`for i := 0; i < data.Len(); i++`\n\nThe second for loop starts at wherever i is, and iterates to the left:\n\n    for j := i; j > 0 && data.Less(j, j-1); j--\n\nEvery iteration of `i` is an unsorted element, which must be compared against the current sorted element to the left. If the value of the element at sub `j` (remember that initially j = i) is lesser than the cell directly to the left of it, we need to swap it.\n\n`j` will always refer to the new cell that is being added, and the swap will keep occuring until the value of the element `j` is greater than the element to the left. \n\nThe second expression of the for loop condition `data.Less(j, j-1)` helps the loop to quit early. We don't need to make unneccessary trips to elements that are already sorted, so once the new element j is in place, just stop.\n\n##main.go\nThis puts everything to use. \n\n\tpackage main\n\n\timport (\n\t\t\"fmt\"\n\t\t\"algorithms/sort\"\n\t)\n\n\ttype genericArray []interface{}\n    \n\tfunc (gA genericArray) Len() int {return len(gA)}\n\t\n    func (gA genericArray) Less(x, y int) bool { \n        return gA[x].(int) < gA[y].(int)\n    } \n    \n    func (gA genericArray) Swap(x int, y int) {\n        gA[x], gA[y] = gA[y], gA[x] \n    }\n\n\tfunc main() {\n        intSlice := genericArray{2, 4, 12, 7, 1, 3}\n\n        fmt.Printf(\"\\nintSlice before being sorted: %v\", intSlice)\n\n        sort.InsertionSort(intSlice)\n\n        fmt.Printf(\"\\n\\nintSlice after being sorted: %v\\n\\n\", intSlice)\n}\n\n## Explanation of main.go\nAfter importing the necessary packages, a named type `genericArray` is created. \n\nTo make use of the `InsertionSort` function, three methods `Len()`, `Less()`, and `Swap()` must be implemented from the interface that `insertionSort` takes as an argument. This is done right after the named type is created, and is also what makes this algorithm polymorphic. The insertion sort function will be applicable on any type as long as we implement the methods that it needs to use.\n\nIn a way, the sort function can be thought of as an operation or process. Having the interface as an argument can be thought of as a list of tools (methods of the interface) that need to be present before the operation is conducted. \n\nThe main function is straightforward. Create a slice of our named type, call the function and pass our slice in. \n\n##Testing\nI created a test file within the same directory as the package, [insertionSort.go](https://github.com/Xercoy/Go-Data-Structures-and-Algorithms/blob/master/src/algorithms/sort/insertionSort_test.go), which tests the sorted output of an empty slice, single element slice, slice of multiple elements, and finally a slice of two duplicate elements. \n\nIt is adapted from the main.go file above and so only tests slices of integers for now. To implement support for other types, simply implement the interface methods for them, create named types as neede, and that's it (I think).\n\nI would definitely appreciate any comments on this, as I didn't really understand testing in Go, nor do I know of any best practices. I do remember seeing a talk about testing standards at Google I/O 2014 which I will review ASAP. \n\n##Other Notes\nI would have liked to iterate through the slice using a slice:\n\t\n    for slice := s[0:1];;{\n\t//Do stuff here\n    if len(slice) + 1 > len(s) {break}\n    slice = s(0:len(slice) + 1]\n    \nStart at the first cell, grow `slice` by 1 cell through each step, and stop when `slice` has grown to capacity. Pretty creative, but somewhat confusing. \n\n###Things learned\n#####Interface Assertion:\nI had to provide my own comparison function. Since the < operator isn't overloaded to handle the interface{} type, and my example was using ints. I simply thought casting would do the trick, which works well from my experience in C:\n\n    return int(gA[x]) < int(gA[y])\n\nThis returned with the error:\n\n    ./insertion_sort.go:25: cannot convert gA[x] (type interface {}) to type int: need type assertion\n\n    //insertion_sort.go:25: cannot convert gA[y] (type interface {}) to type int: need type assertion\n\nGoogle led me to [this](http://stackoverflow.com/questions/14289256/cannot-convert-data-type-interface-to-type-string-need-type-assertion) stack overflow thread. Apparently, the compiler won't even attempt to interpret the bits of the value of an empty interface.\n\nFrom Stephen Winberg on the thread, \"A \"type assertion\" allows you to declare an interface contains a certain concrete type or that its concrete type satisfies another interface.\"\n\nQuoting the [Go Language Specification](golang.org/ref/spec#Type_assertions), \"For an expression x of interface type and a type T, the primary expression x.(T) asserts that x is not nil and that the value stored in x is of type T.\"\n\nSo, an assertion needs to be made instead:\n\n    `gA[x].(int) < gA[y].(int)`\n    \nThis assertion lets the compiler know that the value of type `interface{}` isn't nil, and that it is of the type that is mentioned in parentheses. \n\n#####Methods\n\nMethods must be bound to named types. The type `[]interface{}` (slice of an empty interface) is not a named type. \n\nMethods cannot be bound to an unnamed type, they need to be bound to a 'thing', an 'object'(?) which in Go is a named type.\n\nIn this case, a simple typedef took care of that:\n`type genericArray []interface{}`\n\n#####Swapping\nInstead of creating a variable to temporarily store a value to be swapped:\n\n        var temp, x y\n\t\tx, y = 10, 5\n    \ttemp = x\n        x = y\n        y = temp\n        \nSimply make the assignments in one statement:\n    \n    \tvar temp, x y\n        x, y = 10, 5 //x = 10, y = 5\n        x, y = y, x //x = 5, y = 10\n \t\nThis way, the values of y and x are evaluated before their values are assigned.\n\n###Finally \n- File organization could use some work. I'm thinking about extracting every sorting algorithm in a different file, including interfaces. Not sure If I should do the same for testing functions. I mean, I could always name each test function accordingly. \n\nI hope this was helpful, that's it for now. Will post other thoughts as they come up. If you've made it this far, I really appreciate the time taken to read this post.","html":"<p>If you're not familiar with insertion sort, I recommend <a href=\"https://www.youtube.com/watch?v=ROalU379l3U\">this</a> awesome four minute video which depicts insertion sort in Romanian folk dance. </p>\n\n<p>This implementation of a polymorphic insertion sort strengthened my understanding of interfaces in Go, and finally gave me the chance to write some tests. The whole process went through a good number of rewrites and ended up being very similar to the official Go sort package's implementation.</p>\n\n<p>The type of slice used is an empty interface so that any type could be supported. </p>\n\n<p>There are two main files to this writeup that compliment each other:</p>\n\n<ul>\n<li>insertionSort.go, contains core implementation.</li>\n<li>main.go, describes sample usage.  </li>\n</ul>\n\n<p>All code can be found at <a href=\"https://github.com/Xercoy/Go-Data-Structures-and-Algorithms\">this</a> Github repo.</p>\n\n<h2 id=\"insertionsortgo\">InsertionSort.go</h2>\n\n<pre><code>//insertionSort.go\n\npackage sort\n\nfunc InsertionSort(data Interface) {\n    for i := 0; i &lt; data.Len(); i++ {\n        for j := i; j &gt; 0 &amp;&amp; data.Less(j, j-1); j-- {\n            data.Swap(j, j-1)\n        }\n    }\n}\n\ntype Interface interface {\n    Len() int\n    Less(x int, y int) bool\n    Swap(x int, y int)\n}\n</code></pre>\n\n<h2 id=\"explanationofinsertionsortgo\">Explanation of insertionSort.go</h2>\n\n<p>The magic of <code>insertionSort</code> is in the interface. Once we have a named type that implements the interface, we can pass it to <code>insertionSort</code> which will take care of the rest through use of the methods implemented from the interface.</p>\n\n<p>Once that's understood, the rest of <code>insertionSort</code> is fairly simple. </p>\n\n<p>The first for loop iterates through each cell of a slice from left to right: <br />\n<code>for i := 0; i &lt; data.Len(); i++</code></p>\n\n<p>The second for loop starts at wherever i is, and iterates to the left:</p>\n\n<pre><code>for j := i; j &gt; 0 &amp;&amp; data.Less(j, j-1); j--\n</code></pre>\n\n<p>Every iteration of <code>i</code> is an unsorted element, which must be compared against the current sorted element to the left. If the value of the element at sub <code>j</code> (remember that initially j = i) is lesser than the cell directly to the left of it, we need to swap it.</p>\n\n<p><code>j</code> will always refer to the new cell that is being added, and the swap will keep occuring until the value of the element <code>j</code> is greater than the element to the left. </p>\n\n<p>The second expression of the for loop condition <code>data.Less(j, j-1)</code> helps the loop to quit early. We don't need to make unneccessary trips to elements that are already sorted, so once the new element j is in place, just stop.</p>\n\n<h2 id=\"maingo\">main.go</h2>\n\n<p>This puts everything to use. </p>\n\n<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"algorithms/sort\"\n)\n\ntype genericArray []interface{}\n\nfunc (gA genericArray) Len() int {return len(gA)}\n\nfunc (gA genericArray) Less(x, y int) bool { \n    return gA[x].(int) &lt; gA[y].(int)\n} \n\nfunc (gA genericArray) Swap(x int, y int) {\n    gA[x], gA[y] = gA[y], gA[x] \n}\n\nfunc main() {\n    intSlice := genericArray{2, 4, 12, 7, 1, 3}\n\n    fmt.Printf(\"\\nintSlice before being sorted: %v\", intSlice)\n\n    sort.InsertionSort(intSlice)\n\n    fmt.Printf(\"\\n\\nintSlice after being sorted: %v\\n\\n\", intSlice)\n</code></pre>\n\n<p>}</p>\n\n<h2 id=\"explanationofmaingo\">Explanation of main.go</h2>\n\n<p>After importing the necessary packages, a named type <code>genericArray</code> is created. </p>\n\n<p>To make use of the <code>InsertionSort</code> function, three methods <code>Len()</code>, <code>Less()</code>, and <code>Swap()</code> must be implemented from the interface that <code>insertionSort</code> takes as an argument. This is done right after the named type is created, and is also what makes this algorithm polymorphic. The insertion sort function will be applicable on any type as long as we implement the methods that it needs to use.</p>\n\n<p>In a way, the sort function can be thought of as an operation or process. Having the interface as an argument can be thought of as a list of tools (methods of the interface) that need to be present before the operation is conducted. </p>\n\n<p>The main function is straightforward. Create a slice of our named type, call the function and pass our slice in. </p>\n\n<h2 id=\"testing\">Testing</h2>\n\n<p>I created a test file within the same directory as the package, <a href=\"https://github.com/Xercoy/Go-Data-Structures-and-Algorithms/blob/master/src/algorithms/sort/insertionSort_test.go\">insertionSort.go</a>, which tests the sorted output of an empty slice, single element slice, slice of multiple elements, and finally a slice of two duplicate elements. </p>\n\n<p>It is adapted from the main.go file above and so only tests slices of integers for now. To implement support for other types, simply implement the interface methods for them, create named types as neede, and that's it (I think).</p>\n\n<p>I would definitely appreciate any comments on this, as I didn't really understand testing in Go, nor do I know of any best practices. I do remember seeing a talk about testing standards at Google I/O 2014 which I will review ASAP. </p>\n\n<h2 id=\"othernotes\">Other Notes</h2>\n\n<p>I would have liked to iterate through the slice using a slice:</p>\n\n<pre><code>for slice := s[0:1];;{\n//Do stuff here\nif len(slice) + 1 &gt; len(s) {break}\nslice = s(0:len(slice) + 1]\n</code></pre>\n\n<p>Start at the first cell, grow <code>slice</code> by 1 cell through each step, and stop when <code>slice</code> has grown to capacity. Pretty creative, but somewhat confusing. </p>\n\n<h3 id=\"thingslearned\">Things learned</h3>\n\n<h5 id=\"interfaceassertion\">Interface Assertion:</h5>\n\n<p>I had to provide my own comparison function. Since the &lt; operator isn't overloaded to handle the interface{} type, and my example was using ints. I simply thought casting would do the trick, which works well from my experience in C:</p>\n\n<pre><code>return int(gA[x]) &lt; int(gA[y])\n</code></pre>\n\n<p>This returned with the error:</p>\n\n<pre><code>./insertion_sort.go:25: cannot convert gA[x] (type interface {}) to type int: need type assertion\n\n//insertion_sort.go:25: cannot convert gA[y] (type interface {}) to type int: need type assertion\n</code></pre>\n\n<p>Google led me to <a href=\"http://stackoverflow.com/questions/14289256/cannot-convert-data-type-interface-to-type-string-need-type-assertion\">this</a> stack overflow thread. Apparently, the compiler won't even attempt to interpret the bits of the value of an empty interface.</p>\n\n<p>From Stephen Winberg on the thread, \"A \"type assertion\" allows you to declare an interface contains a certain concrete type or that its concrete type satisfies another interface.\"</p>\n\n<p>Quoting the <a href=\"golang.org/ref/spec#Type_assertions\">Go Language Specification</a>, \"For an expression x of interface type and a type T, the primary expression x.(T) asserts that x is not nil and that the value stored in x is of type T.\"</p>\n\n<p>So, an assertion needs to be made instead:</p>\n\n<pre><code>`gA[x].(int) &lt; gA[y].(int)`\n</code></pre>\n\n<p>This assertion lets the compiler know that the value of type <code>interface{}</code> isn't nil, and that it is of the type that is mentioned in parentheses. </p>\n\n<h5 id=\"methods\">Methods</h5>\n\n<p>Methods must be bound to named types. The type <code>[]interface{}</code> (slice of an empty interface) is not a named type. </p>\n\n<p>Methods cannot be bound to an unnamed type, they need to be bound to a 'thing', an 'object'(?) which in Go is a named type.</p>\n\n<p>In this case, a simple typedef took care of that: <br />\n<code>type genericArray []interface{}</code></p>\n\n<h5 id=\"swapping\">Swapping</h5>\n\n<p>Instead of creating a variable to temporarily store a value to be swapped:</p>\n\n<pre><code>    var temp, x y\n    x, y = 10, 5\n    temp = x\n    x = y\n    y = temp\n</code></pre>\n\n<p>Simply make the assignments in one statement:</p>\n\n<pre><code>    var temp, x y\n    x, y = 10, 5 //x = 10, y = 5\n    x, y = y, x //x = 5, y = 10\n</code></pre>\n\n<p>This way, the values of y and x are evaluated before their values are assigned.</p>\n\n<h3 id=\"finally\">Finally</h3>\n\n<ul>\n<li>File organization could use some work. I'm thinking about extracting every sorting algorithm in a different file, including interfaces. Not sure If I should do the same for testing functions. I mean, I could always name each test function accordingly. </li>\n</ul>\n\n<p>I hope this was helpful, that's it for now. Will post other thoughts as they come up. If you've made it this far, I really appreciate the time taken to read this post.</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1404010115334,"created_by":1,"updated_at":1404147940173,"updated_by":1,"published_at":1404029915583,"published_by":1,"visibility":"public","mobiledoc":null},{"id":7,"uuid":"b4b26942-e68d-4c61-9294-10f146b0f0d6","title":"Detailed Writeup of a Web Server","slug":"detailed-writeup-of-a-web-server","markdown":"Writing a web server in Go does not involve headache. With Go's http package, along with the language's simplicity, it's pretty simple to get a basic \"hello world\" page up and running. The myriad of existing Go web frameworks further compliments this. \n\nAs a person who struggles with being meticulous, I would have liked other tutorials of web applications in Go to be a bit more descriptive. [This post serves moreso a writeup than a tutorial]\n\nThe [net/http](http://golang.org/pkg/net/http/) package provides HTTP client and server capability.\n\n####ListenAndServe\nStarts an HTTP server which listens at the specified address and serves requests with a handler, also supplied as an argument. For most implementations, the handler is usually nil. This specifies that the default handler should be used, `DefaultDerveMux` \n\n####DefaultServeMux\n`Handle` and `HandleFunc` add handlers to DefaultServeMux\n","html":"<p>Writing a web server in Go does not involve headache. With Go's http package, along with the language's simplicity, it's pretty simple to get a basic \"hello world\" page up and running. The myriad of existing Go web frameworks further compliments this. </p>\n\n<p>As a person who struggles with being meticulous, I would have liked other tutorials of web applications in Go to be a bit more descriptive. [This post serves moreso a writeup than a tutorial]</p>\n\n<p>The <a href=\"http://golang.org/pkg/net/http/\">net/http</a> package provides HTTP client and server capability.</p>\n\n<h4 id=\"listenandserve\">ListenAndServe</h4>\n\n<p>Starts an HTTP server which listens at the specified address and serves requests with a handler, also supplied as an argument. For most implementations, the handler is usually nil. This specifies that the default handler should be used, <code>DefaultDerveMux</code> </p>\n\n<h4 id=\"defaultservemux\">DefaultServeMux</h4>\n\n<p><code>Handle</code> and <code>HandleFunc</code> add handlers to DefaultServeMux</p>","image":null,"featured":0,"page":0,"status":"draft","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1404189425382,"created_by":1,"updated_at":1404189549701,"updated_by":1,"published_at":null,"published_by":null,"visibility":"public","mobiledoc":null},{"id":8,"uuid":"c077f881-654e-414d-b770-01448ab3a7c0","title":"Pass by Value VS Pass by Reference","slug":"pass-by-value-vs-pass-by-reference","markdown":"The source escapes me, but I remember reading that a larger portion of the growing Gopher population were coming from backgrounds of higher level languages such as Ruby and Python than from C family languages.\n\nI thought I'd explain the fundamental concepts of passing by reference and passing by value. In addition to what I hope is a clear and accurate understanding, information on how they differ, and usage examples. \n\nOne quick note: **References are Values**. The distinction comes from what the values represent. Don't sweat this detail if it's not clear to you just yet. \n\n###Passing By Reference\nRefers to the concept of being passed a value that is meant to refer to something, in most cases it is an address to a location in memory. \n\nWhen data is being passed by reference, the one thing to understand is that the values involved indicate **where something is**. The address of the data, a value that conveys the location of the data in memory, is still a value, it just so happens that the value refers to something. \n\nIn terms of memory allocation, the amount of space allocated for reference values are pointers. \n\nWhen `passing by reference` an address:\n\n- isn't immediately applicable - the address, usually held by a pointer, must be dereferenced to manipulate the data that it is pointing to.\n\n- is valuable, but not meaningful - it's important that it holds the key to a particular peice in memory that is needed, but the actual value itself is arbitrary. This is why examples with pointers and addresses always have different values. \n\n###Passing By Value\nRefers to the concept of being passed a value that is copied and stored locally.\n\nA value that is `passed by value`, such as a string storing a name or an integer value to an age, is: \n\n- immediately applicable - we can manipulate the data by normal means. \n \n- conveys a direct meaning - both the value and its type are meaningful.  \n\nIn terms of memory allocation, the amount of space allocated for values is equivalent to the size of the value. \n\n### Examples\n\n### My Thoughts\nThere are many people who start their careers programming in higher level languages such as Ruby and Python. From an academic standpoint, even Java. \n\nA consistent comment from people of this background is that they dislike C because of their lack of understanding of pointers. On the other hand, you will never, **ever**, run into a person versed in C to be tripped up on them. \n\nI don't blame people from the first camp at all, it's simply because there is little to deal with when it comes to pointers and higher level languages. In C, you deal with pointers very often. A string is a pointer to a sequence of characters that end in a null byte, a pointer to a function is the address of the first instruction. \n\nYou must also allocate and deallocate your own memory. I'll note that C is second to none in speed, but it's obvious that it's not first in simplicity. This is where Go shines. Simple, fast (getting faster), garbage collected. \n\nIf you're a Gopher who would like to be well versed in Go, get comfy with pointers. \n\nAs a Gopher, Rob Pike is one of our favorite people. If you didn't know already, he worked at Bell Labs alongside the late, legendary Dennis Ritchie, creator of C. There's a reason why Go has pointers, and last I checked, the language implementation is written in C. \n\nKnow pointers!\n\n\n\n\n\n","html":"<p>The source escapes me, but I remember reading that a larger portion of the growing Gopher population were coming from backgrounds of higher level languages such as Ruby and Python than from C family languages.</p>\n\n<p>I thought I'd explain the fundamental concepts of passing by reference and passing by value. In addition to what I hope is a clear and accurate understanding, information on how they differ, and usage examples. </p>\n\n<p>One quick note: <strong>References are Values</strong>. The distinction comes from what the values represent. Don't sweat this detail if it's not clear to you just yet. </p>\n\n<h3 id=\"passingbyreference\">Passing By Reference</h3>\n\n<p>Refers to the concept of being passed a value that is meant to refer to something, in most cases it is an address to a location in memory. </p>\n\n<p>When data is being passed by reference, the one thing to understand is that the values involved indicate <strong>where something is</strong>. The address of the data, a value that conveys the location of the data in memory, is still a value, it just so happens that the value refers to something. </p>\n\n<p>In terms of memory allocation, the amount of space allocated for reference values are pointers. </p>\n\n<p>When <code>passing by reference</code> an address:</p>\n\n<ul>\n<li><p>isn't immediately applicable - the address, usually held by a pointer, must be dereferenced to manipulate the data that it is pointing to.</p></li>\n<li><p>is valuable, but not meaningful - it's important that it holds the key to a particular peice in memory that is needed, but the actual value itself is arbitrary. This is why examples with pointers and addresses always have different values. </p></li>\n</ul>\n\n<h3 id=\"passingbyvalue\">Passing By Value</h3>\n\n<p>Refers to the concept of being passed a value that is copied and stored locally.</p>\n\n<p>A value that is <code>passed by value</code>, such as a string storing a name or an integer value to an age, is: </p>\n\n<ul>\n<li><p>immediately applicable - we can manipulate the data by normal means. </p></li>\n<li><p>conveys a direct meaning - both the value and its type are meaningful.  </p></li>\n</ul>\n\n<p>In terms of memory allocation, the amount of space allocated for values is equivalent to the size of the value. </p>\n\n<h3 id=\"examples\">Examples</h3>\n\n<h3 id=\"mythoughts\">My Thoughts</h3>\n\n<p>There are many people who start their careers programming in higher level languages such as Ruby and Python. From an academic standpoint, even Java. </p>\n\n<p>A consistent comment from people of this background is that they dislike C because of their lack of understanding of pointers. On the other hand, you will never, <strong>ever</strong>, run into a person versed in C to be tripped up on them. </p>\n\n<p>I don't blame people from the first camp at all, it's simply because there is little to deal with when it comes to pointers and higher level languages. In C, you deal with pointers very often. A string is a pointer to a sequence of characters that end in a null byte, a pointer to a function is the address of the first instruction. </p>\n\n<p>You must also allocate and deallocate your own memory. I'll note that C is second to none in speed, but it's obvious that it's not first in simplicity. This is where Go shines. Simple, fast (getting faster), garbage collected. </p>\n\n<p>If you're a Gopher who would like to be well versed in Go, get comfy with pointers. </p>\n\n<p>As a Gopher, Rob Pike is one of our favorite people. If you didn't know already, he worked at Bell Labs alongside the late, legendary Dennis Ritchie, creator of C. There's a reason why Go has pointers, and last I checked, the language implementation is written in C. </p>\n\n<p>Know pointers!</p>","image":null,"featured":0,"page":0,"status":"draft","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1404293404857,"created_by":1,"updated_at":1404293404857,"updated_by":1,"published_at":null,"published_by":null,"visibility":"public","mobiledoc":null},{"id":9,"uuid":"74520aa2-db01-475a-9653-7c0ed512bd7b","title":"Alternate Ways of Importing Packages","slug":"alternate-ways-of-importing-packages","markdown":"There a couple more ways of importing packages in addition to the widely used method of using the `import` keyword and package name as a string literal.\n\nLet's take a look at these different ways, following examples of each. Code for each example is available [here](https://github.com/Xercoy/LearnGoWithMe-Code). \n\n- `import . \"fmt\"` - Allows direct access to the contents of `fmt`.\n\n- `import foo \"fmt\"` - Creates an alias `foo` for `fmt`.\n\n- `import _ \"fmt\"` - Supresses compiler warnings if content from the package isn't used, executes `init()` functions if there are any. Package content is inaccessible, only init functions are included.\n\n##Dot Package Import\nPreceeding the string literal of a package name with a period allows direct access to the package contents. \n\n[dot\\_package\\_import.go](https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/alternate_ways_of_importing_packages/dot_package_import.go)\n```\npackage main\n\nimport (\n        \"fmt\"\n        . \"math\"\n)\n\nfunc main() {\n        fmt.Println(\"Pi is \", Pi)\n        fmt.Println(\"The square root of Pi is \", SqrtPi)\n}\n```\n\nThis example conveys simplicity. The contents of the math package that are used, Pi and SqrtPi, accurately describe its contents. To me, preceeding them with `math.` is redundant.\n\n##Alias Package Import \nPreceeding the string literal of a package name with an alias is self explanatory.\n\n[alias\\_package\\_import.go](https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/alternate_ways_of_importing_packages/alias_package_import.go)\n```\npackage main\n\nimport format \"fmt\"\n\nfunc main() {\n        format.Println(\"Hello, World!\")\n}\n```\nThis is useful in two ways. Consider the well known markdown parser [blackfriday](https://github.com/russross/blackfriday) by RussRoss: \n\n- Readability - giving it a more semantic name would be helpful (since blackfriday is well known, it might not be so helpful in this sense). However, there's a point to be made for `parser.MarkdownBasic(input)` over `blackfriday.(MarkdownBasic)`. \n\n A package with a long or arbitrary name can surely benefit from an alias. \n\n- Organization - if I wanted to replace the package with my own implementation (given that the naming of the functions, constants, etc. are the same), I would only need to modify the string literal.\n\n## Blank Identifier Package Import\n\nPlacing a blank identifier before the string literal will execute the init functions of a package if there are any. For more on inititalization, [this](http://stackoverflow.com/questions/17733220/go-package-initialization) thread on Stackoverflow was helpful. I would like to make a post on this later... \n\nThere's not really a practical example at the moment, but I'd rather share this post first and flesh one out later. \n\n[blank\\_identifier\\_import.go](link)\n```\nimport (\n       \"image\"\n       _ \"image/gif\"\n       _ \"image/png\"\n       _ \"image/jpeg\"\n        )\n```\nThis example depicts an import clause designed to process images without the need for any of the package contents.\n\nThe init functions of the three packages register their particular image format with the image package. Credits to Mark Summerfield's [Programming in Go](http://www.amazon.com/Programming-Go-Creating-Applications-Developers/dp/0321774639) for this example. \n\nContent of packages which include a blank identifier in their import statement is not accessible. They are strictly limited to the execution of their init function(s).\n\nHere is the init function that would be executed for `image/png`, located in the source:\n[http://golang.org/src/pkg/image/png/reader.go](http://golang.org/src/pkg/image/png/reader.go)\n```\nfunc init() {\n        image.RegisterFormat(\"png\", pngHeader, Decode, DecodeConfig)\n}\n```\n\n##Notes\n\n- ####Package Conflicts\nOne important feature of referring to package content by preceeding them with their package name is that it reduces the possibility of naming conflicts. \n\n It's possible to import both a custom package that contains a function named `Printf()` and `fmt` in a program without any issues. However, if the `dot import package method` is used to import both packages, there will be a conflict. This is because the packages are in the same namespace; the `Printf()` functions will have a naming conflict.\n\n- ####Blank Identifier Package Import \nAlthough using the blank identifier import package method doesn't allow access to the remaining package content, it is possible to import the same package again without any error (**Packages are still only imported once**). This is perfectly valid:\n\n        import (\n               _ \"fmt\"\n               \"fmt\"\n                )\n   \n Since the initialization functions are executed in the second import of \"fmt\", this does seem redundant, but still possible!\n\n- A package cannot import itself directly or indirectly.\n\n- It is possible to have more than one init function in a package.\n\n###Helpful Resources\n- I learned of these alternate ways from The [Go Language Specification](http://golang.org/ref/spec) under \"Import Declarations\".","html":"<p>There a couple more ways of importing packages in addition to the widely used method of using the <code>import</code> keyword and package name as a string literal.</p>\n\n<p>Let's take a look at these different ways, following examples of each. Code for each example is available <a href=\"https://github.com/Xercoy/LearnGoWithMe-Code\">here</a>. </p>\n\n<ul>\n<li><p><code>import . \"fmt\"</code> - Allows direct access to the contents of <code>fmt</code>.</p></li>\n<li><p><code>import foo \"fmt\"</code> - Creates an alias <code>foo</code> for <code>fmt</code>.</p></li>\n<li><p><code>import _ \"fmt\"</code> - Supresses compiler warnings if content from the package isn't used, executes <code>init()</code> functions if there are any. Package content is inaccessible, only init functions are included.</p></li>\n</ul>\n\n<h2 id=\"dotpackageimport\">Dot Package Import</h2>\n\n<p>Preceeding the string literal of a package name with a period allows direct access to the package contents. </p>\n\n<p><a href=\"https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/alternate_ways_of_importing_packages/dot_package_import.go\">dot_package_import.go</a></p>\n\n<pre><code>package main\n\nimport (  \n        \"fmt\"\n        . \"math\"\n)\n\nfunc main() {  \n        fmt.Println(\"Pi is \", Pi)\n        fmt.Println(\"The square root of Pi is \", SqrtPi)\n}\n</code></pre>\n\n<p>This example conveys simplicity. The contents of the math package that are used, Pi and SqrtPi, accurately describe its contents. To me, preceeding them with <code>math.</code> is redundant.</p>\n\n<h2 id=\"aliaspackageimport\">Alias Package Import</h2>\n\n<p>Preceeding the string literal of a package name with an alias is self explanatory.</p>\n\n<p><a href=\"https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/alternate_ways_of_importing_packages/alias_package_import.go\">alias_package_import.go</a></p>\n\n<pre><code>package main\n\nimport format \"fmt\"\n\nfunc main() {  \n        format.Println(\"Hello, World!\")\n}\n</code></pre>\n\n<p>This is useful in two ways. Consider the well known markdown parser <a href=\"https://github.com/russross/blackfriday\">blackfriday</a> by RussRoss: </p>\n\n<ul>\n<li><p>Readability - giving it a more semantic name would be helpful (since blackfriday is well known, it might not be so helpful in this sense). However, there's a point to be made for <code>parser.MarkdownBasic(input)</code> over <code>blackfriday.(MarkdownBasic)</code>. </p>\n\n<p>A package with a long or arbitrary name can surely benefit from an alias. </p></li>\n<li><p>Organization - if I wanted to replace the package with my own implementation (given that the naming of the functions, constants, etc. are the same), I would only need to modify the string literal.</p></li>\n</ul>\n\n<h2 id=\"blankidentifierpackageimport\">Blank Identifier Package Import</h2>\n\n<p>Placing a blank identifier before the string literal will execute the init functions of a package if there are any. For more on inititalization, <a href=\"http://stackoverflow.com/questions/17733220/go-package-initialization\">this</a> thread on Stackoverflow was helpful. I would like to make a post on this later... </p>\n\n<p>There's not really a practical example at the moment, but I'd rather share this post first and flesh one out later. </p>\n\n<p><a href=\"link\">blank_identifier_import.go</a></p>\n\n<pre><code>import (  \n       \"image\"\n       _ \"image/gif\"\n       _ \"image/png\"\n       _ \"image/jpeg\"\n        )\n</code></pre>\n\n<p>This example depicts an import clause designed to process images without the need for any of the package contents.</p>\n\n<p>The init functions of the three packages register their particular image format with the image package. Credits to Mark Summerfield's <a href=\"http://www.amazon.com/Programming-Go-Creating-Applications-Developers/dp/0321774639\">Programming in Go</a> for this example. </p>\n\n<p>Content of packages which include a blank identifier in their import statement is not accessible. They are strictly limited to the execution of their init function(s).</p>\n\n<p>Here is the init function that would be executed for <code>image/png</code>, located in the source: <br />\n<a href=\"http://golang.org/src/pkg/image/png/reader.go\">http://golang.org/src/pkg/image/png/reader.go</a></p>\n\n<pre><code>func init() {  \n        image.RegisterFormat(\"png\", pngHeader, Decode, DecodeConfig)\n}\n</code></pre>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li><h4 id=\"packageconflicts\">Package Conflicts</h4>\n\n<p>One important feature of referring to package content by preceeding them with their package name is that it reduces the possibility of naming conflicts. </p>\n\n<p>It's possible to import both a custom package that contains a function named <code>Printf()</code> and <code>fmt</code> in a program without any issues. However, if the <code>dot import package method</code> is used to import both packages, there will be a conflict. This is because the packages are in the same namespace; the <code>Printf()</code> functions will have a naming conflict.</p></li>\n<li><h4 id=\"blankidentifierpackageimport\">Blank Identifier Package Import</h4>\n\n<p>Although using the blank identifier import package method doesn't allow access to the remaining package content, it is possible to import the same package again without any error (<strong>Packages are still only imported once</strong>). This is perfectly valid:</p>\n\n<pre><code>import (\n       _ \"fmt\"\n       \"fmt\"\n        )\n</code></pre>\n\n<p>Since the initialization functions are executed in the second import of \"fmt\", this does seem redundant, but still possible!</p></li>\n<li><p>A package cannot import itself directly or indirectly.</p></li>\n<li><p>It is possible to have more than one init function in a package.</p></li>\n</ul>\n\n<h3 id=\"helpfulresources\">Helpful Resources</h3>\n\n<ul>\n<li>I learned of these alternate ways from The <a href=\"http://golang.org/ref/spec\">Go Language Specification</a> under \"Import Declarations\".</li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1404516992364,"created_by":1,"updated_at":1407161697428,"updated_by":1,"published_at":1404521717055,"published_by":1,"visibility":"public","mobiledoc":null},{"id":10,"uuid":"7523b4a5-8d18-42ec-9fce-884c33b50e9f","title":"Go's unsafe.Pointer Pointer Type","slug":"gos-pointer-pointer-type","markdown":"I was trying find the size of a type in bytes and found that the `sizeof` function of the [`unsafe`](https://golang.org/pkg/unsafe) package does the trick. \n\nThis also led me to stumble upon Go's `Pointer` type, contained in the same package, which is described by the official documentation:\n\n>Pointer represents a pointer to an arbitrary type. There are four special operations available for type Pointer that are not available for other types.\n\nThe operations:\n\n>1) A pointer value of any type can be converted to a Pointer.\n\n>2) A Pointer can be converted to a pointer value of any type.\n\n>3) A uintptr can be converted to a Pointer.\n\n>4) A Pointer can be converted to a uintptr.\n\nNote the distinction between `pointer`(generic type) and `Pointer`(unsafe.Pointer)\n\nA pointer of type `unsafe.Pointer` is capable of overriding Go's type system. A `uintptr` can be converted to an `unsafe.Pointer` type and vice versa. A pointer of any type can be converted into an `unsafe.Pointer`.\n\nI've recently learned that Go does not support pointer arithmetic (more on this later). Coming from C which does allow such functionality, I do think that this is limiting, but also considerate. Here's two reasons why Go's `unsafe.Pointer` pointer type is beneficial:\n\n- It allows programmers to have more control over data.\n\n- Limits this control to people who are aware of its capabilities and consequences. You can only shoot yourself in the foot if you want to! \n \nSo, making these four operations unavailable to pointers by default seems to be more of a safeguard. \n \n## Usage\nSimply convert to and from each type as needed.\n\n```\n// unsafe.Pointer to a pointer to an integer.  \n(* int)(unsafePtr)\n\n// Pointer to an integer to an unsafe.Pointer\nunsafe.Pointer(intPtr)\n\n// unsafe.Pointer to a uintptr\nuintptr(unsafePtr)\n\n// uintptr to unsafe.Pointer\nunsafe.Pointer(unsignedIntVar)\n\n// uintptr to a pointer to an integer\n(* int)(unsafe.Pointer(unsignedIntVar))\n\n// pointer to an integer to a uintptr\nuintptr(unsafe.Pointer(intPtr))\n```\n \n## Example(s)\nWill add more as they come up! Feel free to suggest some.\n\n####Pointer Arithmetic\nTaking advantage of the `unsafe.Pointer` type allows us to actually do some pointer arithmetic, albeit in an ugly way. I just wanted to demonstrate that it's possible.\n\nThe following code is a short example of how pointer arithmetic can be achieved. It also shows a portion of the operations that can be performed on `unsafe.Pointer`.\n\nNote that line 16:\n```\naddressHolder := uintptr(unsafe.Pointer(intPtr)) + unsafe.Sizeof(intArray[0])\n```\nthe assignment of an address to a `uintptr` is illegal in Go 1.3 (see notes section), and is intentionally added to demonstrate this point.\n\n[basic\\_pointer\\_arithmetic.go](https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/gos_pointer_type/basic_pointer_arithmetic.go)|[playground link](http://play.golang.org/p/BAvLtugnif)\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"unsafe\"\n)\n\nfunc main() {\n\tintArray := [...]int{1, 2}\n\n\tfmt.Printf(\"\\nintArray: %v\\n\", intArray)\n\n\tintPtr := &intArray[0]\n\tfmt.Printf(\"\\nintPtr=%p, *intPtr=%d.\\n\", intPtr, *intPtr)\n\n\taddressHolder := uintptr(unsafe.Pointer(intPtr)) + unsafe.Sizeof(intArray[0])\n\n\tintPtr = (*int)(unsafe.Pointer(addressHolder))\n\n\tfmt.Printf(\"\\nintPtr=%p, *intPtr=%d.\\n\\n\", intPtr, *intPtr)\n}\n```\n\nI kept the example code as short as I could for the sake of brevity. Refer to [pointer_arithmetic.go](https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/gos_pointer_type/pointer_arithmetic.go) | [playground link](http://play.golang.org/p/AFJEQvFplt) for a more thorough and detailed explanation.\n\n#### Output \n```\nintArray: [1 2]\n\nintPtr=0x10328130, *intPtr=1.\n\nintPtr=0x10328134, *intPtr=2.\n```\nAs you can see, intPtr originally pointed to the first element of intArray, and was later changed to point to the second one. \n\n####Code analysis\nThere is an array of two integers, 1 and 2. A pointer to an integer `intPtr` is declared and assigned the address of the first element. \n\n**Line 16**:\n```\naddressHolder := uintptr(unsafe.Pointer(intPtr)) + unsafe.Sizeof(intArray[0])\n```\nA `uintptr` variable `addressHolder` is declared and assigned the address that `intPtr` points to + an additional couple of bytes, the size of an element of the particular array. Incrementing the current address by the size in bytes of an element effectively moves the pointer to the next element. Note how `intPtr` was converted to an `unsafe.Pointer`, and then to an `uintptr`. \n\n**Line 18**:\n```\nintPtr = (*int)(unsafe.Pointer(addressHolder))\n```\nFinally, our integer pointer `intPtr` is assigned the value of `addressHolder`. Here, we demonstrate that `unsafe.Pointer` can be converted to a pointer of any type. \n\n##Notes\n\n- A recent change in the Garbage Collector of Go 1.3 concerns how unsafe.Pointer should be used. As the [release notes](http://golang.org/doc/go1.3) states:\n\n> ...Programs that use package unsafe to store integers in pointer-typed values are illegal and will crash if the runtime detects the behavior. Programs that use package unsafe to store pointers in integer-typed values are also illegal...\n\nFor additional details, refer to my previous post on the [Garbage Collection Change in Go 1.3](http://learngowith.me/garbage-collector-change-in-go-1-3/). To detect such illegal behavior, run `go vet` on the suspect package. Applying it to [pointer_arithmetic.go](https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/gos_pointer_type/pointer_arithmetic.go) results in: \n  \n        $ go vet lgwm\n        src/lgwm/pointer_arithmetic.go:27: possible misuse of unsafe.Pointer\n        exit status 1\n\n- A `uintptr` is an integer that is large enough to hold the bit pattern of any address. The size of a `uintptr` is 32 or 64 bits depending on your machine. Don't be fooled by its name. a `uintptr` is an integer data type, and while it can contain an address, Go 1.3's garbage collector change doesn't recommend that an address be stord in a `uintptr`. \n\n## Final Thoughts, Unrelated Comments\n\n- Apologies for the unusually late update!\n\n- I would appreciate any suggestions on upcoming content that people would like to see or haven't seen much of. \n\n- There are a couple of posts that are still brewing as drafts. To name a few, a detailed writeup on a simple webserver using the net/http package, pass by value vs pass by reference, integrating a database into a Go web application. Sounds like overkill, but these are topics that I either need to learn or think that many would benefit from. \n\n- I've completed 40/101 problems on my Go learning repo, [Go 101](https://github.com/Xercoy/Go_101). There will be some problems that are featured as future posts!\n\n- Working on adding code highlighting.","html":"<p>I was trying find the size of a type in bytes and found that the <code>sizeof</code> function of the <a href=\"https://golang.org/pkg/unsafe\"><code>unsafe</code></a> package does the trick. </p>\n\n<p>This also led me to stumble upon Go's <code>Pointer</code> type, contained in the same package, which is described by the official documentation:</p>\n\n<blockquote>\n  <p>Pointer represents a pointer to an arbitrary type. There are four special operations available for type Pointer that are not available for other types.</p>\n</blockquote>\n\n<p>The operations:</p>\n\n<blockquote>\n  <p>1) A pointer value of any type can be converted to a Pointer.</p>\n  \n  <p>2) A Pointer can be converted to a pointer value of any type.</p>\n  \n  <p>3) A uintptr can be converted to a Pointer.</p>\n  \n  <p>4) A Pointer can be converted to a uintptr.</p>\n</blockquote>\n\n<p>Note the distinction between <code>pointer</code>(generic type) and <code>Pointer</code>(unsafe.Pointer)</p>\n\n<p>A pointer of type <code>unsafe.Pointer</code> is capable of overriding Go's type system. A <code>uintptr</code> can be converted to an <code>unsafe.Pointer</code> type and vice versa. A pointer of any type can be converted into an <code>unsafe.Pointer</code>.</p>\n\n<p>I've recently learned that Go does not support pointer arithmetic (more on this later). Coming from C which does allow such functionality, I do think that this is limiting, but also considerate. Here's two reasons why Go's <code>unsafe.Pointer</code> pointer type is beneficial:</p>\n\n<ul>\n<li><p>It allows programmers to have more control over data.</p></li>\n<li><p>Limits this control to people who are aware of its capabilities and consequences. You can only shoot yourself in the foot if you want to! </p></li>\n</ul>\n\n<p>So, making these four operations unavailable to pointers by default seems to be more of a safeguard. </p>\n\n<h2 id=\"usage\">Usage</h2>\n\n<p>Simply convert to and from each type as needed.</p>\n\n<pre><code>// unsafe.Pointer to a pointer to an integer.  \n(* int)(unsafePtr)\n\n// Pointer to an integer to an unsafe.Pointer\nunsafe.Pointer(intPtr)\n\n// unsafe.Pointer to a uintptr\nuintptr(unsafePtr)\n\n// uintptr to unsafe.Pointer\nunsafe.Pointer(unsignedIntVar)\n\n// uintptr to a pointer to an integer\n(* int)(unsafe.Pointer(unsignedIntVar))\n\n// pointer to an integer to a uintptr\nuintptr(unsafe.Pointer(intPtr))  \n</code></pre>\n\n<h2 id=\"examples\">Example(s)</h2>\n\n<p>Will add more as they come up! Feel free to suggest some.</p>\n\n<h4 id=\"pointerarithmetic\">Pointer Arithmetic</h4>\n\n<p>Taking advantage of the <code>unsafe.Pointer</code> type allows us to actually do some pointer arithmetic, albeit in an ugly way. I just wanted to demonstrate that it's possible.</p>\n\n<p>The following code is a short example of how pointer arithmetic can be achieved. It also shows a portion of the operations that can be performed on <code>unsafe.Pointer</code>.</p>\n\n<p>Note that line 16:  </p>\n\n<pre><code>addressHolder := uintptr(unsafe.Pointer(intPtr)) + unsafe.Sizeof(intArray[0])  \n</code></pre>\n\n<p>the assignment of an address to a <code>uintptr</code> is illegal in Go 1.3 (see notes section), and is intentionally added to demonstrate this point.</p>\n\n<p><a href=\"https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/gos_pointer_type/basic_pointer_arithmetic.go\">basic_pointer_arithmetic.go</a>|<a href=\"http://play.golang.org/p/BAvLtugnif\">playground link</a></p>\n\n<pre><code>package main\n\nimport (  \n    \"fmt\"\n    \"unsafe\"\n)\n\nfunc main() {  \n    intArray := [...]int{1, 2}\n\n    fmt.Printf(\"\\nintArray: %v\\n\", intArray)\n\n    intPtr := &amp;intArray[0]\n    fmt.Printf(\"\\nintPtr=%p, *intPtr=%d.\\n\", intPtr, *intPtr)\n\n    addressHolder := uintptr(unsafe.Pointer(intPtr)) + unsafe.Sizeof(intArray[0])\n\n    intPtr = (*int)(unsafe.Pointer(addressHolder))\n\n    fmt.Printf(\"\\nintPtr=%p, *intPtr=%d.\\n\\n\", intPtr, *intPtr)\n}\n</code></pre>\n\n<p>I kept the example code as short as I could for the sake of brevity. Refer to <a href=\"https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/gos_pointer_type/pointer_arithmetic.go\">pointer_arithmetic.go</a> | <a href=\"http://play.golang.org/p/AFJEQvFplt\">playground link</a> for a more thorough and detailed explanation.</p>\n\n<h4 id=\"output\">Output</h4>\n\n<pre><code>intArray: [1 2]\n\nintPtr=0x10328130, *intPtr=1.\n\nintPtr=0x10328134, *intPtr=2.  \n</code></pre>\n\n<p>As you can see, intPtr originally pointed to the first element of intArray, and was later changed to point to the second one. </p>\n\n<h4 id=\"codeanalysis\">Code analysis</h4>\n\n<p>There is an array of two integers, 1 and 2. A pointer to an integer <code>intPtr</code> is declared and assigned the address of the first element. </p>\n\n<p><strong>Line 16</strong>:</p>\n\n<pre><code>addressHolder := uintptr(unsafe.Pointer(intPtr)) + unsafe.Sizeof(intArray[0])  \n</code></pre>\n\n<p>A <code>uintptr</code> variable <code>addressHolder</code> is declared and assigned the address that <code>intPtr</code> points to + an additional couple of bytes, the size of an element of the particular array. Incrementing the current address by the size in bytes of an element effectively moves the pointer to the next element. Note how <code>intPtr</code> was converted to an <code>unsafe.Pointer</code>, and then to an <code>uintptr</code>. </p>\n\n<p><strong>Line 18</strong>:</p>\n\n<pre><code>intPtr = (*int)(unsafe.Pointer(addressHolder))  \n</code></pre>\n\n<p>Finally, our integer pointer <code>intPtr</code> is assigned the value of <code>addressHolder</code>. Here, we demonstrate that <code>unsafe.Pointer</code> can be converted to a pointer of any type. </p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>A recent change in the Garbage Collector of Go 1.3 concerns how unsafe.Pointer should be used. As the <a href=\"http://golang.org/doc/go1.3\">release notes</a> states:</li>\n</ul>\n\n<blockquote>\n  <p>...Programs that use package unsafe to store integers in pointer-typed values are illegal and will crash if the runtime detects the behavior. Programs that use package unsafe to store pointers in integer-typed values are also illegal...</p>\n</blockquote>\n\n<p>For additional details, refer to my previous post on the <a href=\"http://learngowith.me/garbage-collector-change-in-go-1-3/\">Garbage Collection Change in Go 1.3</a>. To detect such illegal behavior, run <code>go vet</code> on the suspect package. Applying it to <a href=\"https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/gos_pointer_type/pointer_arithmetic.go\">pointer_arithmetic.go</a> results in: </p>\n\n<pre><code>    $ go vet lgwm\n    src/lgwm/pointer_arithmetic.go:27: possible misuse of unsafe.Pointer\n    exit status 1\n</code></pre>\n\n<ul>\n<li>A <code>uintptr</code> is an integer that is large enough to hold the bit pattern of any address. The size of a <code>uintptr</code> is 32 or 64 bits depending on your machine. Don't be fooled by its name. a <code>uintptr</code> is an integer data type, and while it can contain an address, Go 1.3's garbage collector change doesn't recommend that an address be stord in a <code>uintptr</code>. </li>\n</ul>\n\n<h2 id=\"finalthoughtsunrelatedcomments\">Final Thoughts, Unrelated Comments</h2>\n\n<ul>\n<li><p>Apologies for the unusually late update!</p></li>\n<li><p>I would appreciate any suggestions on upcoming content that people would like to see or haven't seen much of. </p></li>\n<li><p>There are a couple of posts that are still brewing as drafts. To name a few, a detailed writeup on a simple webserver using the net/http package, pass by value vs pass by reference, integrating a database into a Go web application. Sounds like overkill, but these are topics that I either need to learn or think that many would benefit from. </p></li>\n<li><p>I've completed 40/101 problems on my Go learning repo, <a href=\"https://github.com/Xercoy/Go_101\">Go 101</a>. There will be some problems that are featured as future posts!</p></li>\n<li><p>Working on adding code highlighting.</p></li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1404665434443,"created_by":1,"updated_at":1406330467296,"updated_by":1,"published_at":1406188900202,"published_by":1,"visibility":"public","mobiledoc":null},{"id":11,"uuid":"4190877f-055e-4566-9e06-a0c30b4e0dd9","title":"Garbage Collector Change in Go 1.3","slug":"garbage-collector-change-in-go-1-3","markdown":"I was in the middle of writing a post on using Go's Pointer data type and realized that Go 1.3 affects how it can be used.\n\nHere's demonstration of a slight change in behavior of the Garbage collector from Go 1.2 to Go 1.3\n\nAs the [release notes](http://golang.org/doc/go1.3) mentioned of the garbage collector:\n\n>... a non-pointer Go value such as an integer will never be mistaken for a pointer and prevent unused memory from being reclaimed... Starting with Go 1.3, the runtime assumes that values with pointer type contain pointers and other values do not.\n\nIn other words, addresses should only be assigned to pointers. Integers or any other data type which is used to store an address is at risk of having its space reclaimed by the GC. \n\n##Demonstration\n\nYou can view the example program I've created [here](https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/garbage_collector_change_in_go13/gc_change_example.go) or directly on the [playground](http://play.golang.org/p/wtXHJfMBjl). Note that the playground is running the latest version of Go (1.3 at the time of this article).'\n\n**Warning**, this example makes use of capabilities that are now considered bad practice and even illegal. See the last bullet on the **Notes** section for more details. \n\n####Explanation\n\n**tl;dr**: Allocate two integers with `new()`. Take one pointer and assign the value of the second pointer to it. Store the address of the lonely portion of memory in an integer variable, in this case a `uintptr`. Invoke the GC and display the content of the address stored in the integer variable. Observe that:\n\n- In Go 1.2, the integer is still present.\n\n- In Go 1.3, the integer value will no longer be present, indicating that its space has been reclaimed. This is because the address was stored in an integer variable. The GC wouldn't have reclaimed it if a pointer was storing the address.\n\n**overview**: The example program has three primary variables: two pointers to integers `(intPtr1, intPtr2)` and one uintptr`(addressHolder)`. Space for two integers are allocated (with values 100 and 999) with their addresses stored in `intPtr1` and `intPtr2`, respectively.\n\nAfter that, `addressHolder` is assigned the address of `intPtr1`. \n\nThen a copy of intPtr2 is assigned to intPtr1, essentially leaving nothing to point to the address held in `addressHolder`.\n\nThe garbage collector is finally called, reclaiming the memory at the address held in `addressHolder`.\n\nTo confirm, dereference the address held in addressHolder using the unsafe package (again, see last bullet in **notes** for details) which yields different results in 1.2 and 1.3. Pay attention to the last lines of output in the following section.\n\n##Output\n###Go 1.2\n```\nintPtr1 = 0xc210000018, dereferenced value = 100\nintPtr2 = 0xc210000020, dereferenced value = 999\n\naddressHolder(uintptr) has been assigned the value of intPtr1 which is the address 0xc210000018.\n\nintPtr1 has been assigned the value of inPtr2 which is the address 0xc210000020, dereferenced value = 999\n\nCalling runtime.GC()\n\naddressHolder(uintptr), value = 0xc210000018, dereferenced value = 100\n\n\n```\n###Go 1.3\n```\nintPtr1 = 0x10334020, dereferenced value = 100\nintPtr2 = 0x10334024, dereferenced value = 999\n\naddressHolder(uintptr) has been assigned the value of intPtr1 which is the address 0x10334020.\n\nintPtr1 has been assigned the value of inPtr2 which is the address 0x10334024, dereferenced value = 999\n\nCalling runtime.GC()\n\naddressHolder(uintptr), value = 0x10334020, dereferenced value = 271794224\n```\n\nThat's about it, coming up next will be a post on Go's Pointer data type. I'd appreciate any input!\n\n##Notes\n- A uintptr is an unsigned integer of 32 or 64 bits depending on your machine.\n\n- The release notes also mention that:\n> Programs that use package unsafe to store integers in pointer-typed values are illegal and will crash if the runtime detects the behavior. Programs that use package unsafe to store pointers in integer-typed values are also illegal but more difficult to diagnose during execution. \n\n The example code does violate this rule, ironically to enforce it.\n\n To detect this behavior on a package, run `go vet PACKAGE_NAME`. the [vet](https://godoc.org/code.google.com/p/go.tools/cmd/vet) command is used to examine code for anything fishy. Running this on my example resulted in only warnings. I was not able to make the program crash.\n\n- If you're looking for a version manager, I recommend looking into [gvm](https://github.com/moovweb/gvm) if you haven't already. Inspired by [rvm](https://rvm.io/)(Ruby Version Manager), it works pretty well and was very useful in testing the example under different versions of Go. \n\n- One way to monitor memory is to take advantage of the runtime package which contains a `MemStats` type, used to record memory allocator statistics. Populate the struct with runtime.ReadMemStats() and you're given valuable information such as the number of allocated bytes, the last time the GC ran in absolute time, and total number of allocated objects in the Heap. Click [here](http://golang.org/pkg/runtime/#MemStats) for the `MemStats` type in the `runtime` package. \n\n##Things learned\n- [gvm](https://github.com/moovweb/gvm)(Go Version Manager), not to be confused with [gvm](http://gvmtool.net/)(Groovy enVerionment Manager) \n- Existence of the runtime package and the ability to manually call the Garbage Collector and monitor memory.\n- Usage of [`go vet`](https://godoc.org/code.google.com/p/go.tools/cmd/vet)","html":"<p>I was in the middle of writing a post on using Go's Pointer data type and realized that Go 1.3 affects how it can be used.</p>\n\n<p>Here's demonstration of a slight change in behavior of the Garbage collector from Go 1.2 to Go 1.3</p>\n\n<p>As the <a href=\"http://golang.org/doc/go1.3\">release notes</a> mentioned of the garbage collector:</p>\n\n<blockquote>\n  <p>... a non-pointer Go value such as an integer will never be mistaken for a pointer and prevent unused memory from being reclaimed... Starting with Go 1.3, the runtime assumes that values with pointer type contain pointers and other values do not.</p>\n</blockquote>\n\n<p>In other words, addresses should only be assigned to pointers. Integers or any other data type which is used to store an address is at risk of having its space reclaimed by the GC. </p>\n\n<h2 id=\"demonstration\">Demonstration</h2>\n\n<p>You can view the example program I've created <a href=\"https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/garbage_collector_change_in_go13/gc_change_example.go\">here</a> or directly on the <a href=\"http://play.golang.org/p/wtXHJfMBjl\">playground</a>. Note that the playground is running the latest version of Go (1.3 at the time of this article).'</p>\n\n<p><strong>Warning</strong>, this example makes use of capabilities that are now considered bad practice and even illegal. See the last bullet on the <strong>Notes</strong> section for more details. </p>\n\n<h4 id=\"explanation\">Explanation</h4>\n\n<p><strong>tl;dr</strong>: Allocate two integers with <code>new()</code>. Take one pointer and assign the value of the second pointer to it. Store the address of the lonely portion of memory in an integer variable, in this case a <code>uintptr</code>. Invoke the GC and display the content of the address stored in the integer variable. Observe that:</p>\n\n<ul>\n<li><p>In Go 1.2, the integer is still present.</p></li>\n<li><p>In Go 1.3, the integer value will no longer be present, indicating that its space has been reclaimed. This is because the address was stored in an integer variable. The GC wouldn't have reclaimed it if a pointer was storing the address.</p></li>\n</ul>\n\n<p><strong>overview</strong>: The example program has three primary variables: two pointers to integers <code>(intPtr1, intPtr2)</code> and one uintptr<code>(addressHolder)</code>. Space for two integers are allocated (with values 100 and 999) with their addresses stored in <code>intPtr1</code> and <code>intPtr2</code>, respectively.</p>\n\n<p>After that, <code>addressHolder</code> is assigned the address of <code>intPtr1</code>. </p>\n\n<p>Then a copy of intPtr2 is assigned to intPtr1, essentially leaving nothing to point to the address held in <code>addressHolder</code>.</p>\n\n<p>The garbage collector is finally called, reclaiming the memory at the address held in <code>addressHolder</code>.</p>\n\n<p>To confirm, dereference the address held in addressHolder using the unsafe package (again, see last bullet in <strong>notes</strong> for details) which yields different results in 1.2 and 1.3. Pay attention to the last lines of output in the following section.</p>\n\n<h2 id=\"output\">Output</h2>\n\n<h3 id=\"go12\">Go 1.2</h3>\n\n<pre><code>intPtr1 = 0xc210000018, dereferenced value = 100  \nintPtr2 = 0xc210000020, dereferenced value = 999\n\naddressHolder(uintptr) has been assigned the value of intPtr1 which is the address 0xc210000018.\n\nintPtr1 has been assigned the value of inPtr2 which is the address 0xc210000020, dereferenced value = 999\n\nCalling runtime.GC()\n\naddressHolder(uintptr), value = 0xc210000018, dereferenced value = 100\n</code></pre>\n\n<h3 id=\"go13\">Go 1.3</h3>\n\n<pre><code>intPtr1 = 0x10334020, dereferenced value = 100  \nintPtr2 = 0x10334024, dereferenced value = 999\n\naddressHolder(uintptr) has been assigned the value of intPtr1 which is the address 0x10334020.\n\nintPtr1 has been assigned the value of inPtr2 which is the address 0x10334024, dereferenced value = 999\n\nCalling runtime.GC()\n\naddressHolder(uintptr), value = 0x10334020, dereferenced value = 271794224  \n</code></pre>\n\n<p>That's about it, coming up next will be a post on Go's Pointer data type. I'd appreciate any input!</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li><p>A uintptr is an unsigned integer of 32 or 64 bits depending on your machine.</p></li>\n<li><p>The release notes also mention that:</p>\n\n<blockquote>\n  <p>Programs that use package unsafe to store integers in pointer-typed values are illegal and will crash if the runtime detects the behavior. Programs that use package unsafe to store pointers in integer-typed values are also illegal but more difficult to diagnose during execution. </p>\n</blockquote>\n\n<p>The example code does violate this rule, ironically to enforce it.</p>\n\n<p>To detect this behavior on a package, run <code>go vet PACKAGE_NAME</code>. the <a href=\"https://godoc.org/code.google.com/p/go.tools/cmd/vet\">vet</a> command is used to examine code for anything fishy. Running this on my example resulted in only warnings. I was not able to make the program crash.</p></li>\n<li><p>If you're looking for a version manager, I recommend looking into <a href=\"https://github.com/moovweb/gvm\">gvm</a> if you haven't already. Inspired by <a href=\"https://rvm.io/\">rvm</a>(Ruby Version Manager), it works pretty well and was very useful in testing the example under different versions of Go. </p></li>\n<li><p>One way to monitor memory is to take advantage of the runtime package which contains a <code>MemStats</code> type, used to record memory allocator statistics. Populate the struct with runtime.ReadMemStats() and you're given valuable information such as the number of allocated bytes, the last time the GC ran in absolute time, and total number of allocated objects in the Heap. Click <a href=\"http://golang.org/pkg/runtime/#MemStats\">here</a> for the <code>MemStats</code> type in the <code>runtime</code> package. </p></li>\n</ul>\n\n<h2 id=\"thingslearned\">Things learned</h2>\n\n<ul>\n<li><a href=\"https://github.com/moovweb/gvm\">gvm</a>(Go Version Manager), not to be confused with <a href=\"http://gvmtool.net/\">gvm</a>(Groovy enVerionment Manager) </li>\n<li>Existence of the runtime package and the ability to manually call the Garbage Collector and monitor memory.</li>\n<li>Usage of <a href=\"https://godoc.org/code.google.com/p/go.tools/cmd/vet\"><code>go vet</code></a></li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1405221783723,"created_by":1,"updated_at":1405265709059,"updated_by":1,"published_at":1405264654515,"published_by":1,"visibility":"public","mobiledoc":null},{"id":12,"uuid":"c323a3ab-2134-405b-83e6-2793cd9d530b","title":"Go's flag Package, Creating a CLI Tool","slug":"gos-flag-package-creating-a-cli-tool","markdown":"Go's `flag` package makes the development of a command line interface tool very simple.\n\nIn an attempt to learn more about Go and the [GNU Coreutils](http://www.gnu.org/software/coreutils/manual/coreutils.pdf), I created a Go program which emulates the `yes` utility with some added functionality. I hope this post provides enough information to inspire readers to start writing their own. \n\n\n**How This Post is Structured**\n\nThere are three sections of the post that discuss the `flag` package and development of the `yes` tool. Because this post is bulky from code examples and explanations, click <a href=\"#The-Flag-Package-P1-Basics\">**here**</a> to start a trail that mentions only flag package content; proceed to each section through links that begin with \"Skip\".  \n\nRefer to the code examples and their explanations for a thorough experience.\n\n**Background Info**\n\nThe [`flag`](http://golang.org/pkg/flag/) package provides functionality for parsing the flags that are provided when executing the utility. We will need this to parse the options/flags. \n\nThe `yes` utility will print the space separated arguments followed by a space and newline, repeating until interrupted. If there are no arguments, the character 'y' is considered output.\n\n**Notable Things You Will Learn of the ` flag` Package**\n\n- Two main ways to define a flag.\n- How to define your own flag in a third way using the `flag.Var` function.\n- The `flag.Flag` data type.\n- Handling arguments after flags are parsed.\n\n**My `yes` Implementation Differences** - This Go implementation of the `yes` util will include a `limit` flag to specify number of times the output string will be displayed. \n\n# Contents\n1. <a href=\"#Contents-1\">Usage without arguments</a>.\n\n2. <a href=\"#Contents-2\">Using the `flag` package to parse flags and arguments.</a>\n\n3. <a href=\"#Contents-3\">Putting everything together; basic usage.</a>\n\n## <a name=\"Contents-1\"></a>1. Usage Without Arguments\nAs specified within the docs, executing the `yes` tool without any arguments will simply display the character y followed by a space and newline. Here's what that looks like:\n\n[usage\\_without\\_arguments.go](https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/gos_flag_package_creating_a_cli_tool/usage_without_arguments.go)\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tfor true {\n\t\tif len(os.Args) == 1 {\n\t\t\tfmt.Printf(\"y \\n\")\n\t\t} else {\n        \tbreak;\n        }\n\t}\n}\n```\n\n\n####Explanation \nThe endless loop outputs `\"y \"` on a single line if there aren't any command line arguments. How is this determined? Well, `len(os.Args)` will always be 1 for a running, argumentless program. In any case, recall that `os.Args[0]` is a string value which represents the running program. \n\n**NOTE**\nIt is possible to calculate the number of arguments (excluding program, starting at 0) using `len(flag.Args())`. `flag.Args()` returns a string slice of the arguments after the flags have been parsed. Remember, `flag.Parse()`, explained in the next section, must be executed before this package variable may be used. See [usage\\_without\\_arguments\\_using\\_flagArgs.go](https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/gos_flag_package_creating_a_cli_tool/usage_without_arguments_using_flagArgs.go) for an example.\n\n<a name=\"Contents-2\"></a>\n## 2. Using the `flag` Package to Parse Flags and Arguments\n\nLet's review the three flags and the type of each one:\n\n- `version` - boolean flag, displays current version of utility.\n\n- `help` - boolean flag, displays text information of basic usage.\n\n- `limit` - integer flag, determines the number of times that the string argument(s) will be displayed. \n\n### <a name=\"FlagPackageOverview\"></a>The Version flag and a thorough overview of the `flag` package\n\n<a name=\"The-Flag-Package-P1-Basics\"></a> \n**Flag package basics** - Basically, every flag needs to be defined. Functions in the `flag` package are used to do so, enabling a variable to contain the flag value or point to a variable containing the value. These two different ways will be covered.\n\nAfter doing so, the `flag.Parse()` function must be called to do the processing - validating received flag values, placing them, etc.. Variables which contain or point to flag values are useless until this function is called. \n\nThe explanation section shows how the version flag was implemented, a look at the `flag.Flag` struct, and how the to access the `flag.Flag` struct fields using `flag.Lookup`. <a href=\"#Flag-Package-P2-Alternative-Way-To-Define-A-Flag\">\n\nSkip to 'Alternative Way of Defining a Flag'</a>\n\n[version_flag.go](https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/gos_flag_package_creating_a_cli_tool/version_flag.go)\n```\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tvar version *bool\n\tversion = flag.Bool(\"version\", false, \"0.1\")\n\n\tflag.Parse()\n\n\tif *version {\n\t\tfmt.Printf(\"Version %s\\n\", (flag.Lookup(\"version\")).Usage)\n\t\tos.Exit(0)\n\t}\n}\n```\n###Explanation\n\nWe declare a variable `version`, which is of type pointer to a boolean.\n\nAs the [documentation](http://golang.org/pkg/flag/#Bool) describes `flag.Bool`:\n> BoolVar defines a bool flag with specified name, default value, and usage string. The argument p points to a bool variable in which to store the value of the flag.\n\nLet's go through the lines of interest.\n\n---\n```\n`version = flag.Bool(\"version\", false, \"0.1\")`\n```\n`flag.Bool` defines a flag with a name of `version` which has a default value of `false` and a usage string `\"0.1\"`\n\nNow that the flag is defined, `flag.Parse()` is executed and works its magic. \n\n---\n```\nif *version {\n...\n}\n```\n\nIn the conditional expression of the if statement, we dereference the pointer variable `version` whose code block will be executed based on the dereferenced value.\n\n\n---\n\n```\nflag.Lookup(\"version\")).Usage\n```\nThe argument to the `Printf` statement is simply evaluated to \"0.1\". Understanding how requires more explanation of the package. I'll start by mentioning the [`flag.Flag`](http://golang.org/pkg/flag/#Flag) type:\n\n```\ntype Flag struct {\n        Name     string // name of flag\n        Usage    string // help message\n        Value    Value  // value as set\n        DefValue string // default value as text\n}\n```\n\nWhen `flag.Bool` was called, a flag was defined in the name of the first argument (important in next paragraph!) and memory was allocated for a `flag.Flag` in which its fields were populated with the provided arguments.\n\nCalling [`flag.Lookup`](http://golang.org/pkg/flag/#Lookup) and providing it with a string literal of the name of a defined flag (\"version\") returns the reflecting `flag.Flag`.\n\nThus, we simply append `.Usage` to first dereference the returned address and then retrieve `Usage` field of the struct, which is indeed the string `\"0.1\"`. Cool, huh!?!\n\n### Sample Output\n```\n$ ./version_flag\n>\n\n$ ./version_flag -version\n> Version 0.1\n\n$ ./version_flag --version\n> Version 0.1\n\n$ ./version_flag --version=false\n>\n\n$ ./version_flag --version=123\n>invalid boolean value \"123\" for -version: strconv.ParseBool: parsing \"123\": invalid syntax\nUsage of ./version_flag:\n  -version=false: 0.1\n\n```\nRefer to the package notes for some explanations for the output.\n\nNow that this is out of the way, on to implementing the `help` flag!\n\n\n### The `help` Flag, More on the `flag` Package\n\nThe last section was the most intense part of this post. Implementation of the `help` flag is similar but with minor differences. Like the `version` flag, the `help` flag will be used to simply display information. \n\n<a name=\"Flag-Package-P2-Alternative-Way-To-Define-A-Flag\"></a>**Alternative Way of Defining a Flag** - The implementation of the `help` flag demonstrates a `flag` package function that enables the variable to be of type `bool` using `flag.BoolVar` rather than a pointer using `flag.Bool`. See the explanation for more detailed info. \n\n<a href=\"#Flag-Package-P3-Defining-Your-Own-Flags\">Skip to 'Remaining Flags, Defining Your Own'</a>\n\n[help_flag.go](https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/gos_flag_package_creating_a_cli_tool/help_flag.go)\n```\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\n\tvar help bool\n\n\tvar helpText = /*help text omitted for readability, shown in output instead.*/\n    \n\tflag.BoolVar(&help, \"help\", false, helpText)\n\n\tflag.Parse()\n\n\tif help {\n\t\tfmt.Printf(\"%s\\n\", flag.Lookup(\"help\").Usage)\n\t\tos.Exit(0)\n\t}\n}\n```\n###Explanation\nThe minor difference in implementing this flag is the use of a different function and variable type. \n\n---\n<a name=\"NFPAMention\"></a>\n```\nvar help bool\n```\nUnlike the `version` flag implementation, `help` is of type bool and not a pointer to a bool. The `flag.BoolVar` function is different from the `flag.Bool` function by its additional, first argument - a pointer to a bool. In other words, the return value of `flag.Bool` is shoved into `flag.BoolVar` as an argument (See <a href=\"NFPA\"> bullet A</a> in \"Notes on the Flag Package\" for more details). \n\nWhat does this mean? The difference is simply in the type and usage of the variable defined to store the flag value. For the `version` flag it was a pointer to a boolean, while this `help` flag is actually of type boolean. Obviously the `help` variable does not need to be dereferenced.\n\n###Sample Output **(modified for readability)**\n```\n$ ./help_flag\n\n> \nUsage:\n\n--help               displays usage information\n\n--version            displays utility version \n\n--limit              specifies number of times arguments will be displayed.\n```\n\n<a name=\"Flag-Package-P3-Defining-Your-Own-Flags\"></a>\n### Remaining Flags, Defining Your Own\n\nAt this point you are more than capable of creating your own CLI tool.\n\nThe implementation of the last flag `limit` demonstrates how a custom flag can be created.\n\nBasically, use the `flag.Var` function:\n\n`Var(value Value, name string, usage string)` \n\nThe first argument is of interface type [Value](http://golang.org/pkg/flag#Value)\n```\ntype Value interface {\n        String() string\n        Set(string) error\n}\n```\n\nAll that's needed for the custom flag is to satisfy the two methods. String (`String() string`) returns a string value of an argument, and Set (`Set(string) error`) is responsible for processing and placing the string argument(s) into the data type which will contain it.\n\nTo retrieve the contents of a custom flag, we **should** satisfy the [`Getter`](http://golang.org/pkg/flag#Getter) interface. It is simply a wrapper of `Value` and includes one additional, aptly named `Get` function. That's about it! \n\n<a href=\"#Flag-Package-P4-Parsing-Non-Flag-Arguments\"> Skip to 'Parsing Non Flag Arguments'</a>\n\nThe following section is an example of how a custom flag could be designed, view [limit\\_flag\\_with\\_yes.go](link) for a practical example.\n\n[limit_flag.go](https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/gos_flag_package_creating_a_cli_tool/limit_flag.go)\n```\npackage main\n\nimport(\n\"fmt\"\n\"flag\"\n\"strconv\"\n)\n\ntype CustomStruct struct {\n\tFlagValue int\n}\n\nfunc (cF *CustomStruct) String() string {\n\treturn strconv.Itoa(cF.FlagValue)\n}\n\nfunc (cF *CustomStruct) Set(s string) error {\n\tcF.FlagValue, _ = strconv.Atoi(s)\n\t\n\treturn nil\n}\n\nfunc (cF *CustomStruct) Get() int {\n\treturn cF.FlagValue\n}\n\nfunc (cF *CustomStruct) IsSet() bool {\n\tif cF.FlagValue == -1 {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc main() {\n\tlimitFlag := CustomStruct{-1}\n\n\tflag.Var(&limitFlag, \"limit\", \"Limits output\")\n\n\tflag.Parse()\n\n\tif limitFlag.IsSet() {\n\t\tfmt.Printf(\"\\nLimit: %d\\n\\n\", limitFlag.Get())\n\t} else {\n\t\tfmt.Printf(\"\\nLimit flag not included.\\n\\n\")\n\t}\n}\n```\n####Explanation\n\nA struct was defined, `CustomStruct`, which contains an integer field. Methods `Set` and `String` are defined which satisfies the `Value` interface, and `Get` is defined which satisfies the `Getter` interface. Note that an extra method was defined, `IsSet`.\n\nLet's take a look at the `Set`, `String`, and `IsSet` methods.\n\n---\nThe `Set` Method\n```\nfunc (cF *CustomStruct) Set(s string) error {\n\tcF.FlagValue, _ = strconv.Atoi(s)\n\t\n\treturn nil\n}\n```\nThis method is called by the `flag.Var` function, used to parse the received string argument and place the value(s) in a container. In this case, we simply just convert the string to an integer and store it accordingly into the `FlagValue` field.\n\n---\n\nThe `String` Method\n```\nfunc (cF *CustomStruct) String() string {\n\treturn strconv.Itoa(cF.FlagValue)\n}\n```\nThis method simply returns a string value used to describe the contents of the flag value. Nothing else is needed in this case other than a conversion, but think about how this could be used to describe a flag value of a slice of strings or something...\n\n---\n\nThe `IsSet` Method\n\n```\nfunc (cF *CustomStruct) IsSet() bool {\n\tif cF.FlagValue == -1 {\n\t\treturn false\n\t}\n\n\treturn true\n}\n```\n\nNotice that the `flag.Var` function doesn't have an argument to specify a default value. I implemented this method to determine when the flag has been set. -1 was used since valid flag values can only be 0 or greater. \n\nIn order for this method to behave correctly, the flag value must be initialized with the value -1, as seen in the `main` function.\n\n\nNow, on to the final part...\n\n##3. <a name=\"Contents-3\"></a>Putting it All Together, Parsing Remaining Arguments\n\n<a name=\"Flag-Package-P4-Parsing-Non-Flag-Arguments\"></a>**Parsing Non Flag Arguments** -After `flag.Parse` is called, use the `flag.Args` function to retrieve a string slice of the arguments. Remember that `flag.Parse` must be called first! See [parsing_arguments.go](link) for an example. \n\n<a href=\"#conclusion\">Skip to 'Conclusion'</a>\n\n# `Yes` In Action\nThe final product, [yes.go](https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/gos_flag_package_creating_a_cli_tool/yes.go) incorporates all of the material that has been covered.  \n\n####yes.go sample output\nThe help option was omitted for readibility but works as it should. the `...` denotes infinite output.\n\n```\n$ ./yes\n>y \ny \n...\n\n$ ./yes cat    dog mouse\n> cat dog mouse\ncat dog mouse\n...\n\n$ ./yes -version\n>Version 0.1\n\n$ ./yes -limit 2\n>y\ny\n\n$ ./yes -limit 3 duck duck goose\n>duck duck goose\nduck duck goose\nduck duck goose\n```\n---\n\n# <a name=\"conclusion\"></a>Conclusion\n\nYou have now learned enough about the `flag` package to:\n\n- Define and parse flags\n- Define your own custom flags\n- Parse non flag arguments\n\nIf you've made it this far, thanks so much. While this is the lengthiest of all the articles, I hope that every bit of it was useful and entertaining. \n\nThis post in particular has led me to think about the way future posts should be written in terms of length and design - I'd especially appreciate feedback on these aspects. Until next week!\n\n---\n\n# Notes on the `flag` package\n\n- **Including Flags**\nAs the [documentation](http://golang.org/pkg/flag/) notes, when providing a flag, `-` and `--` are equivalent.\n\n- **Flag Syntax**\nThe documentation mentions the accepted syntax for including flags:\n ```-flag\n-flag=x\n-flag x\n ```\n\n The third option is not permitted for boolean flags.\n\n Acceptable integer flag values:\n\n ```9876 00239 0x4321 -1999```\n\n Acceptable boolean flag values:\n \n ```1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False```\n\n- **One Variable, Multiple Flags**\n\n It is possible to define more than one flag name for a variable. \n\n For instance, we can implement a shorthand version of a flag 'crash'. \n\n Flag Definition\n ```flag.IntVar(&randomFlag, \"crash\", -1, \"foobarbaz\")```\n\n Shorthand Flag Definition\n ```flag.IntVar(&randomFlag, \"c\", -1, \"foobarbaz\")```\n\n- **Similar Functions**\n The `flag` package contains multiple functions that are \"pairs\" (Int, IntVar, Float64, Float64Var). \n\n I've pondered why both implementations need to exist and counted a total of eight \"pairs\" - eight functions in the package which differs its counterpart by only one argument. At first this seemed to me like clutter.\n\n I can only explain the need with a couple of reasons and would appreciate your input.\n\n Imagine that the values of flags all needed to be evaluated as a whole (not uncommon). Instead of dealing with different data types, it would be more manageable for every flag to be represented through a pointer.\n\n# Other Notes\n \n- Fun Fact - `yes` recevied publicity in 2006 for being used to detect a random shutdown defect in Macbooks. Source :[Wikipedia](http://en.wikipedia.org/wiki/Yes_(Unix))\n \n-  **POSIXLY_CORRECT** - As noted in recent [coreutils news](http://code.metager.de/source/xref/gnu/coreutils/NEWS) (Section starting on line 3469), `yes` parses the `--help` and `--version` flags as strings unless the `POSIXLY_CORRECT` environment variable is set (see for more information on what this means). Initially decided to implement a flag for this but decided not to in the interest of value. Still worth a quick read: http://en.wikipedia.org/wiki/POSIX\n\n# Unrelated Notes\n\n- Looking into coreutils did yield some pretty great resources: [Exit Codes](http://www.faqs.org/docs/abs/HTML/exitcodes.html), [Common Command Line Options](https://www.gnu.org/software/coreutils/manual/html_node/Common-options.html#Common-options)\n\n- I mistakenly thought that I had to emulate exit signals and found this awesome Go package which I will probably make a post on. [os/signal](http://golang.org/pkg/os/signal/)\n\n- In retrospect, I probably should have broken this post up into chunks to make this more digestable. This developed into a chapter or large section of a book rather than a blog post.\n\n- I'm very proud of how this post turned out, given the amount of time and effort that was put into it...\n\n\n","html":"<p>Go's <code>flag</code> package makes the development of a command line interface tool very simple.</p>\n\n<p>In an attempt to learn more about Go and the <a href=\"http://www.gnu.org/software/coreutils/manual/coreutils.pdf\">GNU Coreutils</a>, I created a Go program which emulates the <code>yes</code> utility with some added functionality. I hope this post provides enough information to inspire readers to start writing their own. </p>\n\n<p><strong>How This Post is Structured</strong></p>\n\n<p>There are three sections of the post that discuss the <code>flag</code> package and development of the <code>yes</code> tool. Because this post is bulky from code examples and explanations, click <a href=\"#The-Flag-Package-P1-Basics\"><strong>here</strong></a> to start a trail that mentions only flag package content; proceed to each section through links that begin with \"Skip\".  </p>\n\n<p>Refer to the code examples and their explanations for a thorough experience.</p>\n\n<p><strong>Background Info</strong></p>\n\n<p>The <a href=\"http://golang.org/pkg/flag/\"><code>flag</code></a> package provides functionality for parsing the flags that are provided when executing the utility. We will need this to parse the options/flags. </p>\n\n<p>The <code>yes</code> utility will print the space separated arguments followed by a space and newline, repeating until interrupted. If there are no arguments, the character 'y' is considered output.</p>\n\n<p><strong>Notable Things You Will Learn of the <code>flag</code> Package</strong></p>\n\n<ul>\n<li>Two main ways to define a flag.</li>\n<li>How to define your own flag in a third way using the <code>flag.Var</code> function.</li>\n<li>The <code>flag.Flag</code> data type.</li>\n<li>Handling arguments after flags are parsed.</li>\n</ul>\n\n<p><strong>My <code>yes</code> Implementation Differences</strong> - This Go implementation of the <code>yes</code> util will include a <code>limit</code> flag to specify number of times the output string will be displayed. </p>\n\n<h1 id=\"contents\">Contents</h1>\n\n<ol>\n<li><p><a href=\"#Contents-1\">Usage without arguments</a>.</p></li>\n<li><p><a href=\"#Contents-2\">Using the <code>flag</code> package to parse flags and arguments.</a></p></li>\n<li><p><a href=\"#Contents-3\">Putting everything together; basic usage.</a></p></li>\n</ol>\n\n<h2 id=\"anamecontents1a1usagewithoutarguments\"><a name=\"Contents-1\"></a>1. Usage Without Arguments</h2>\n\n<p>As specified within the docs, executing the <code>yes</code> tool without any arguments will simply display the character y followed by a space and newline. Here's what that looks like:</p>\n\n<p><a href=\"https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/gos_flag_package_creating_a_cli_tool/usage_without_arguments.go\">usage_without_arguments.go</a></p>\n\n<pre><code>package main\n\nimport (  \n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {  \n    for true {\n        if len(os.Args) == 1 {\n            fmt.Printf(\"y \\n\")\n        } else {\n            break;\n        }\n    }\n}\n</code></pre>\n\n<h4 id=\"explanation\">Explanation</h4>\n\n<p>The endless loop outputs <code>\"y \"</code> on a single line if there aren't any command line arguments. How is this determined? Well, <code>len(os.Args)</code> will always be 1 for a running, argumentless program. In any case, recall that <code>os.Args[0]</code> is a string value which represents the running program. </p>\n\n<p><strong>NOTE</strong>\nIt is possible to calculate the number of arguments (excluding program, starting at 0) using <code>len(flag.Args())</code>. <code>flag.Args()</code> returns a string slice of the arguments after the flags have been parsed. Remember, <code>flag.Parse()</code>, explained in the next section, must be executed before this package variable may be used. See <a href=\"https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/gos_flag_package_creating_a_cli_tool/usage_without_arguments_using_flagArgs.go\">usage_without_arguments_using_flagArgs.go</a> for an example.</p>\n\n<p><a name=\"Contents-2\"></a>  </p>\n\n<h2 id=\"2usingtheflagpackagetoparseflagsandarguments\">2. Using the <code>flag</code> Package to Parse Flags and Arguments</h2>\n\n<p>Let's review the three flags and the type of each one:</p>\n\n<ul>\n<li><p><code>version</code> - boolean flag, displays current version of utility.</p></li>\n<li><p><code>help</code> - boolean flag, displays text information of basic usage.</p></li>\n<li><p><code>limit</code> - integer flag, determines the number of times that the string argument(s) will be displayed. </p></li>\n</ul>\n\n<h3 id=\"anameflagpackageoverviewatheversionflagandathoroughoverviewoftheflagpackage\"><a name=\"FlagPackageOverview\"></a>The Version flag and a thorough overview of the <code>flag</code> package</h3>\n\n<p><a name=\"The-Flag-Package-P1-Basics\"></a> <br />\n<strong>Flag package basics</strong> - Basically, every flag needs to be defined. Functions in the <code>flag</code> package are used to do so, enabling a variable to contain the flag value or point to a variable containing the value. These two different ways will be covered.</p>\n\n<p>After doing so, the <code>flag.Parse()</code> function must be called to do the processing - validating received flag values, placing them, etc.. Variables which contain or point to flag values are useless until this function is called. </p>\n\n<p>The explanation section shows how the version flag was implemented, a look at the <code>flag.Flag</code> struct, and how the to access the <code>flag.Flag</code> struct fields using <code>flag.Lookup</code>. <a href=\"#Flag-Package-P2-Alternative-Way-To-Define-A-Flag\"></p>\n\n<p>Skip to 'Alternative Way of Defining a Flag'</a></p>\n\n<p><a href=\"https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/gos_flag_package_creating_a_cli_tool/version_flag.go\">version_flag.go</a></p>\n\n<pre><code>package main\n\nimport (  \n    \"flag\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {  \n    var version *bool\n    version = flag.Bool(\"version\", false, \"0.1\")\n\n    flag.Parse()\n\n    if *version {\n        fmt.Printf(\"Version %s\\n\", (flag.Lookup(\"version\")).Usage)\n        os.Exit(0)\n    }\n}\n</code></pre>\n\n<h3 id=\"explanation\">Explanation</h3>\n\n<p>We declare a variable <code>version</code>, which is of type pointer to a boolean.</p>\n\n<p>As the <a href=\"http://golang.org/pkg/flag/#Bool\">documentation</a> describes <code>flag.Bool</code>:  </p>\n\n<blockquote>\n  <p>BoolVar defines a bool flag with specified name, default value, and usage string. The argument p points to a bool variable in which to store the value of the flag.</p>\n</blockquote>\n\n<p>Let's go through the lines of interest.</p>\n\n<hr />\n\n<pre><code>`version = flag.Bool(\"version\", false, \"0.1\")`\n</code></pre>\n\n<p><code>flag.Bool</code> defines a flag with a name of <code>version</code> which has a default value of <code>false</code> and a usage string <code>\"0.1\"</code></p>\n\n<p>Now that the flag is defined, <code>flag.Parse()</code> is executed and works its magic. </p>\n\n<hr />\n\n<pre><code>if *version {  \n...\n}\n</code></pre>\n\n<p>In the conditional expression of the if statement, we dereference the pointer variable <code>version</code> whose code block will be executed based on the dereferenced value.</p>\n\n<hr />\n\n<pre><code>flag.Lookup(\"version\")).Usage  \n</code></pre>\n\n<p>The argument to the <code>Printf</code> statement is simply evaluated to \"0.1\". Understanding how requires more explanation of the package. I'll start by mentioning the <a href=\"http://golang.org/pkg/flag/#Flag\"><code>flag.Flag</code></a> type:</p>\n\n<pre><code>type Flag struct {  \n        Name     string // name of flag\n        Usage    string // help message\n        Value    Value  // value as set\n        DefValue string // default value as text\n}\n</code></pre>\n\n<p>When <code>flag.Bool</code> was called, a flag was defined in the name of the first argument (important in next paragraph!) and memory was allocated for a <code>flag.Flag</code> in which its fields were populated with the provided arguments.</p>\n\n<p>Calling <a href=\"http://golang.org/pkg/flag/#Lookup\"><code>flag.Lookup</code></a> and providing it with a string literal of the name of a defined flag (\"version\") returns the reflecting <code>flag.Flag</code>.</p>\n\n<p>Thus, we simply append <code>.Usage</code> to first dereference the returned address and then retrieve <code>Usage</code> field of the struct, which is indeed the string <code>\"0.1\"</code>. Cool, huh!?!</p>\n\n<h3 id=\"sampleoutput\">Sample Output</h3>\n\n<pre><code>$ ./version_flag\n&gt;\n\n$ ./version_flag -version\n&gt; Version 0.1\n\n$ ./version_flag --version\n&gt; Version 0.1\n\n$ ./version_flag --version=false\n&gt;\n\n$ ./version_flag --version=123\n&gt;invalid boolean value \"123\" for -version: strconv.ParseBool: parsing \"123\": invalid syntax\nUsage of ./version_flag:  \n  -version=false: 0.1\n</code></pre>\n\n<p>Refer to the package notes for some explanations for the output.</p>\n\n<p>Now that this is out of the way, on to implementing the <code>help</code> flag!</p>\n\n<h3 id=\"thehelpflagmoreontheflagpackage\">The <code>help</code> Flag, More on the <code>flag</code> Package</h3>\n\n<p>The last section was the most intense part of this post. Implementation of the <code>help</code> flag is similar but with minor differences. Like the <code>version</code> flag, the <code>help</code> flag will be used to simply display information. </p>\n\n<p><a name=\"Flag-Package-P2-Alternative-Way-To-Define-A-Flag\"></a><strong>Alternative Way of Defining a Flag</strong> - The implementation of the <code>help</code> flag demonstrates a <code>flag</code> package function that enables the variable to be of type <code>bool</code> using <code>flag.BoolVar</code> rather than a pointer using <code>flag.Bool</code>. See the explanation for more detailed info. </p>\n\n<p><a href=\"#Flag-Package-P3-Defining-Your-Own-Flags\">Skip to 'Remaining Flags, Defining Your Own'</a></p>\n\n<p><a href=\"https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/gos_flag_package_creating_a_cli_tool/help_flag.go\">help_flag.go</a></p>\n\n<pre><code>package main\n\nimport (  \n    \"flag\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n\n    var help bool\n\n    var helpText = /*help text omitted for readability, shown in output instead.*/\n\n    flag.BoolVar(&amp;help, \"help\", false, helpText)\n\n    flag.Parse()\n\n    if help {\n        fmt.Printf(\"%s\\n\", flag.Lookup(\"help\").Usage)\n        os.Exit(0)\n    }\n}\n</code></pre>\n\n<h3 id=\"explanation\">Explanation</h3>\n\n<p>The minor difference in implementing this flag is the use of a different function and variable type. </p>\n\n<hr />\n\n<p><a name=\"NFPAMention\"></a>  </p>\n\n<pre><code>var help bool  \n</code></pre>\n\n<p>Unlike the <code>version</code> flag implementation, <code>help</code> is of type bool and not a pointer to a bool. The <code>flag.BoolVar</code> function is different from the <code>flag.Bool</code> function by its additional, first argument - a pointer to a bool. In other words, the return value of <code>flag.Bool</code> is shoved into <code>flag.BoolVar</code> as an argument (See <a href=\"NFPA\"> bullet A</a> in \"Notes on the Flag Package\" for more details). </p>\n\n<p>What does this mean? The difference is simply in the type and usage of the variable defined to store the flag value. For the <code>version</code> flag it was a pointer to a boolean, while this <code>help</code> flag is actually of type boolean. Obviously the <code>help</code> variable does not need to be dereferenced.</p>\n\n<h3 id=\"sampleoutputmodifiedforreadability\">Sample Output <strong>(modified for readability)</strong></h3>\n\n<pre><code>$ ./help_flag\n\n&gt; \nUsage:\n\n--help               displays usage information\n\n--version            displays utility version \n\n--limit              specifies number of times arguments will be displayed.\n</code></pre>\n\n<p><a name=\"Flag-Package-P3-Defining-Your-Own-Flags\"></a>  </p>\n\n<h3 id=\"remainingflagsdefiningyourown\">Remaining Flags, Defining Your Own</h3>\n\n<p>At this point you are more than capable of creating your own CLI tool.</p>\n\n<p>The implementation of the last flag <code>limit</code> demonstrates how a custom flag can be created.</p>\n\n<p>Basically, use the <code>flag.Var</code> function:</p>\n\n<p><code>Var(value Value, name string, usage string)</code> </p>\n\n<p>The first argument is of interface type <a href=\"http://golang.org/pkg/flag#Value\">Value</a>  </p>\n\n<pre><code>type Value interface {  \n        String() string\n        Set(string) error\n}\n</code></pre>\n\n<p>All that's needed for the custom flag is to satisfy the two methods. String (<code>String() string</code>) returns a string value of an argument, and Set (<code>Set(string) error</code>) is responsible for processing and placing the string argument(s) into the data type which will contain it.</p>\n\n<p>To retrieve the contents of a custom flag, we <strong>should</strong> satisfy the <a href=\"http://golang.org/pkg/flag#Getter\"><code>Getter</code></a> interface. It is simply a wrapper of <code>Value</code> and includes one additional, aptly named <code>Get</code> function. That's about it! </p>\n\n<p><a href=\"#Flag-Package-P4-Parsing-Non-Flag-Arguments\"> Skip to 'Parsing Non Flag Arguments'</a></p>\n\n<p>The following section is an example of how a custom flag could be designed, view <a href=\"link\">limit_flag_with_yes.go</a> for a practical example.</p>\n\n<p><a href=\"https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/gos_flag_package_creating_a_cli_tool/limit_flag.go\">limit_flag.go</a></p>\n\n<pre><code>package main\n\nimport(  \n\"fmt\"  \n\"flag\"  \n\"strconv\"  \n)\n\ntype CustomStruct struct {  \n    FlagValue int\n}\n\nfunc (cF *CustomStruct) String() string {  \n    return strconv.Itoa(cF.FlagValue)\n}\n\nfunc (cF *CustomStruct) Set(s string) error {  \n    cF.FlagValue, _ = strconv.Atoi(s)\n\n    return nil\n}\n\nfunc (cF *CustomStruct) Get() int {  \n    return cF.FlagValue\n}\n\nfunc (cF *CustomStruct) IsSet() bool {  \n    if cF.FlagValue == -1 {\n        return false\n    }\n\n    return true\n}\n\nfunc main() {  \n    limitFlag := CustomStruct{-1}\n\n    flag.Var(&amp;limitFlag, \"limit\", \"Limits output\")\n\n    flag.Parse()\n\n    if limitFlag.IsSet() {\n        fmt.Printf(\"\\nLimit: %d\\n\\n\", limitFlag.Get())\n    } else {\n        fmt.Printf(\"\\nLimit flag not included.\\n\\n\")\n    }\n}\n</code></pre>\n\n<h4 id=\"explanation\">Explanation</h4>\n\n<p>A struct was defined, <code>CustomStruct</code>, which contains an integer field. Methods <code>Set</code> and <code>String</code> are defined which satisfies the <code>Value</code> interface, and <code>Get</code> is defined which satisfies the <code>Getter</code> interface. Note that an extra method was defined, <code>IsSet</code>.</p>\n\n<p>Let's take a look at the <code>Set</code>, <code>String</code>, and <code>IsSet</code> methods.</p>\n\n<hr />\n\n<p>The <code>Set</code> Method  </p>\n\n<pre><code>func (cF *CustomStruct) Set(s string) error {  \n    cF.FlagValue, _ = strconv.Atoi(s)\n\n    return nil\n}\n</code></pre>\n\n<p>This method is called by the <code>flag.Var</code> function, used to parse the received string argument and place the value(s) in a container. In this case, we simply just convert the string to an integer and store it accordingly into the <code>FlagValue</code> field.</p>\n\n<hr />\n\n<p>The <code>String</code> Method  </p>\n\n<pre><code>func (cF *CustomStruct) String() string {  \n    return strconv.Itoa(cF.FlagValue)\n}\n</code></pre>\n\n<p>This method simply returns a string value used to describe the contents of the flag value. Nothing else is needed in this case other than a conversion, but think about how this could be used to describe a flag value of a slice of strings or something...</p>\n\n<hr />\n\n<p>The <code>IsSet</code> Method</p>\n\n<pre><code>func (cF *CustomStruct) IsSet() bool {  \n    if cF.FlagValue == -1 {\n        return false\n    }\n\n    return true\n}\n</code></pre>\n\n<p>Notice that the <code>flag.Var</code> function doesn't have an argument to specify a default value. I implemented this method to determine when the flag has been set. -1 was used since valid flag values can only be 0 or greater. </p>\n\n<p>In order for this method to behave correctly, the flag value must be initialized with the value -1, as seen in the <code>main</code> function.</p>\n\n<p>Now, on to the final part...</p>\n\n<h2 id=\"3anamecontents3aputtingitalltogetherparsingremainingarguments\">3. <a name=\"Contents-3\"></a>Putting it All Together, Parsing Remaining Arguments</h2>\n\n<p><a name=\"Flag-Package-P4-Parsing-Non-Flag-Arguments\"></a><strong>Parsing Non Flag Arguments</strong> -After <code>flag.Parse</code> is called, use the <code>flag.Args</code> function to retrieve a string slice of the arguments. Remember that <code>flag.Parse</code> must be called first! See <a href=\"link\">parsing_arguments.go</a> for an example. </p>\n\n<p><a href=\"#conclusion\">Skip to 'Conclusion'</a></p>\n\n<h1 id=\"yesinaction\"><code>Yes</code> In Action</h1>\n\n<p>The final product, <a href=\"https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/gos_flag_package_creating_a_cli_tool/yes.go\">yes.go</a> incorporates all of the material that has been covered.  </p>\n\n<h4 id=\"yesgosampleoutput\">yes.go sample output</h4>\n\n<p>The help option was omitted for readibility but works as it should. the <code>...</code> denotes infinite output.</p>\n\n<pre><code>$ ./yes\n&gt;y \ny  \n...\n\n$ ./yes cat    dog mouse\n&gt; cat dog mouse\ncat dog mouse  \n...\n\n$ ./yes -version\n&gt;Version 0.1\n\n$ ./yes -limit 2\n&gt;y\ny\n\n$ ./yes -limit 3 duck duck goose\n&gt;duck duck goose\nduck duck goose  \nduck duck goose  \n</code></pre>\n\n<hr />\n\n<h1 id=\"anameconclusionaconclusion\"><a name=\"conclusion\"></a>Conclusion</h1>\n\n<p>You have now learned enough about the <code>flag</code> package to:</p>\n\n<ul>\n<li>Define and parse flags</li>\n<li>Define your own custom flags</li>\n<li>Parse non flag arguments</li>\n</ul>\n\n<p>If you've made it this far, thanks so much. While this is the lengthiest of all the articles, I hope that every bit of it was useful and entertaining. </p>\n\n<p>This post in particular has led me to think about the way future posts should be written in terms of length and design - I'd especially appreciate feedback on these aspects. Until next week!</p>\n\n<hr />\n\n<h1 id=\"notesontheflagpackage\">Notes on the <code>flag</code> package</h1>\n\n<ul>\n<li><p><strong>Including Flags</strong>\nAs the <a href=\"http://golang.org/pkg/flag/\">documentation</a> notes, when providing a flag, <code>-</code> and <code>--</code> are equivalent.</p></li>\n<li><p><strong>Flag Syntax</strong>\nThe documentation mentions the accepted syntax for including flags: <br />\n<code>-flag\n-flag=x\n-flag x\n</code></p>\n\n<p>The third option is not permitted for boolean flags.</p>\n\n<p>Acceptable integer flag values:</p>\n\n<p><code>9876 00239 0x4321 -1999</code></p>\n\n<p>Acceptable boolean flag values:</p>\n\n<p><code>1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False</code></p></li>\n<li><p><strong>One Variable, Multiple Flags</strong></p>\n\n<p>It is possible to define more than one flag name for a variable. </p>\n\n<p>For instance, we can implement a shorthand version of a flag 'crash'. </p>\n\n<p>Flag Definition\n<code>flag.IntVar(&amp;randomFlag, \"crash\", -1, \"foobarbaz\")</code></p>\n\n<p>Shorthand Flag Definition\n<code>flag.IntVar(&amp;randomFlag, \"c\", -1, \"foobarbaz\")</code></p></li>\n<li><p><strong>Similar Functions</strong>\nThe <code>flag</code> package contains multiple functions that are \"pairs\" (Int, IntVar, Float64, Float64Var). </p>\n\n<p>I've pondered why both implementations need to exist and counted a total of eight \"pairs\" - eight functions in the package which differs its counterpart by only one argument. At first this seemed to me like clutter.</p>\n\n<p>I can only explain the need with a couple of reasons and would appreciate your input.</p>\n\n<p>Imagine that the values of flags all needed to be evaluated as a whole (not uncommon). Instead of dealing with different data types, it would be more manageable for every flag to be represented through a pointer.</p></li>\n</ul>\n\n<h1 id=\"othernotes\">Other Notes</h1>\n\n<ul>\n<li><p>Fun Fact - <code>yes</code> recevied publicity in 2006 for being used to detect a random shutdown defect in Macbooks. Source :<a href=\"http://en.wikipedia.org/wiki/Yes_(Unix)\">Wikipedia</a></p></li>\n<li><p><strong>POSIXLY_CORRECT</strong> - As noted in recent <a href=\"http://code.metager.de/source/xref/gnu/coreutils/NEWS\">coreutils news</a> (Section starting on line 3469), <code>yes</code> parses the <code>--help</code> and <code>--version</code> flags as strings unless the <code>POSIXLY_CORRECT</code> environment variable is set (see for more information on what this means). Initially decided to implement a flag for this but decided not to in the interest of value. Still worth a quick read: <a href='http://en.wikipedia.org/wiki/POSIX'>http://en.wikipedia.org/wiki/POSIX</a></p></li>\n</ul>\n\n<h1 id=\"unrelatednotes\">Unrelated Notes</h1>\n\n<ul>\n<li><p>Looking into coreutils did yield some pretty great resources: <a href=\"http://www.faqs.org/docs/abs/HTML/exitcodes.html\">Exit Codes</a>, <a href=\"https://www.gnu.org/software/coreutils/manual/html_node/Common-options.html#Common-options\">Common Command Line Options</a></p></li>\n<li><p>I mistakenly thought that I had to emulate exit signals and found this awesome Go package which I will probably make a post on. <a href=\"http://golang.org/pkg/os/signal/\">os/signal</a></p></li>\n<li><p>In retrospect, I probably should have broken this post up into chunks to make this more digestable. This developed into a chapter or large section of a book rather than a blog post.</p></li>\n<li><p>I'm very proud of how this post turned out, given the amount of time and effort that was put into it...</p></li>\n</ul>","image":null,"featured":1,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1407686304952,"created_by":1,"updated_at":1408240514011,"updated_by":1,"published_at":1408236462775,"published_by":1,"visibility":"public","mobiledoc":null},{"id":13,"uuid":"a650043e-c892-4fda-a959-da00a41ad401","title":"Late Post","slug":"late-post","markdown":"Just wanted to mention that the weekly post which was intended to be released within the past couple of days is still being written.\n\nConsistency and dependability mean a lot to me, so I wanted to at least make an update and let the regular visitors know what's going on. \n\nExpect two posts to be released this week.\n\nThanks!","html":"<p>Just wanted to mention that the weekly post which was intended to be released within the past couple of days is still being written.</p>\n\n<p>Consistency and dependability mean a lot to me, so I wanted to at least make an update and let the regular visitors know what's going on. </p>\n\n<p>Expect two posts to be released this week.</p>\n\n<p>Thanks!</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1407760583276,"created_by":1,"updated_at":1407771947899,"updated_by":1,"published_at":1407760588705,"published_by":1,"visibility":"public","mobiledoc":null},{"id":15,"uuid":"e7ac0ec1-934c-49e7-a918-46bf52218264","title":"A Binary Tree in Go","slug":"a-binary-tree-in-go","markdown":"Most of the implementations that I've seen online are restricted to only one type. As a refresher I've followed suit and implemented a basic binary tree which works with integers. Next week's post will be on a polymorphic binary tree. \n\nThe entire code is in a single file, methods, driver, and all. Notes will be made in the last section of this post instead of explaining everything in detail. If you're new to binary trees, view [the wiki](http://en.wikipedia.org/wiki/Binary_tree) page.\n\nYou can view my Go implementation on [Github](https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/binary_tree/binaryTreeV1.go) or see it in action on the [Go Playground](http://play.golang.org/p/rhHjzaE8zx).\n\nAnyways, here's my take at a polymorphic tree: \n\nHave an interface which specifies methods that abstract the core parts of a node - Left, Right, Data, Comparison Function, etc. This way the struct that represents a node can have more fields than two pointers and one data variable - all the binary tree package functions care about are: \n\n- being able to 'get' and 'set' the left and right children along with other important fields\n- a comparison function so that it can traverse the tree correctly in finding, inserting, and deleting nodes\n\nUnlike this week's version, the polymorphic binary tree will be created as a package.\n\n##Notes\n- I'm heading back to school within two weeks to finish off my Senior year, woohoo! Unfortunately that means there's less time to work on all things Go. Instead of releasing weekly posts that may not be of much value, I'll be releasing material as soon as any are ready.\n\n- Started working on a tool to simplify my workflow. I can't begin to describe how rewarding it is to create a tool that solves a personal problem. I hate that I didn't do it earlier, but I'm glad I started to with Go. Going to develop it more and will release a post on it later.\n\n- Other Go related projects are in the works...\n\n##Notes on the Code\n\nBasic operations:\n\n- **Insert(newValue interface{})  error** - Traverses the tree along a route determined by whether the value to be inserted is greater, less than, or equal to the current node's value. Before traversing to a node by invoking the `Insert()` method on the left or right child, the particular field is checked to see if its value is nil. If so, allocate space for a new node and assign the left/right child to point to it, then copy the new integer to be inserted into the new node's `Data` field. While an `error` is returned, there is currently no functionality which checks for any errors. \n\n- **Find(value interface{}) *Node** - Traverses tree in search of a Node's `Data` field that matches the `value` argument. Upon success the address of the node is returned, nil is returned otherwise. \n\n\n- **Delete(value interface{}) *Node** - Recursive method which deletes most nodes by removing pointer references to them. The single use case where this won't happen is with the root node. Removing a root node will simply set its `Data` field to nil. In this case such a node is considered empty. \n\n- **Height() int** - Recursive method that returns 1 + the maximum value of a call to Height for each of the node's children. If the node is considered empty, 0 is returned. So each node is given a value of 1, and the height is the sum of the tallest 'node trail'.\n\n- **FindMin() int** - Recursive method which returns the smallest integer among the left children of a tree. \n\n- **FindMax() int** - Recursive method which returns the largest value among the right children of a tree.\n\n- **Print()** - Prints the value of each node, traversing the tree in a preorder fashion. \n\n- **min(num1 int, num2 int) int** and **max(num1 int, num2 int) int** - behaves as expected. Naming was kept lowercase to conform to package naming conventions where lowercase functions are not exported. In this case, the practice describes helper functions. \n\n---\n\n- Since a struct cannot be nil, there needs to be some way to determine whether a struct is 'empty'. The data field which stores integers is an empty interface. Since an empty interface can in fact be nil, that's what I checked for. \n\n- Didnt realize that there were so many different ways Delete() could be written. I made sure to write mine on my own version before observing others. Creating algorithms off the top of my head was fun but time consuming.","html":"<p>Most of the implementations that I've seen online are restricted to only one type. As a refresher I've followed suit and implemented a basic binary tree which works with integers. Next week's post will be on a polymorphic binary tree. </p>\n\n<p>The entire code is in a single file, methods, driver, and all. Notes will be made in the last section of this post instead of explaining everything in detail. If you're new to binary trees, view <a href=\"http://en.wikipedia.org/wiki/Binary_tree\">the wiki</a> page.</p>\n\n<p>You can view my Go implementation on <a href=\"https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/binary_tree/binaryTreeV1.go\">Github</a> or see it in action on the <a href=\"http://play.golang.org/p/rhHjzaE8zx\">Go Playground</a>.</p>\n\n<p>Anyways, here's my take at a polymorphic tree: </p>\n\n<p>Have an interface which specifies methods that abstract the core parts of a node - Left, Right, Data, Comparison Function, etc. This way the struct that represents a node can have more fields than two pointers and one data variable - all the binary tree package functions care about are: </p>\n\n<ul>\n<li>being able to 'get' and 'set' the left and right children along with other important fields</li>\n<li>a comparison function so that it can traverse the tree correctly in finding, inserting, and deleting nodes</li>\n</ul>\n\n<p>Unlike this week's version, the polymorphic binary tree will be created as a package.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li><p>I'm heading back to school within two weeks to finish off my Senior year, woohoo! Unfortunately that means there's less time to work on all things Go. Instead of releasing weekly posts that may not be of much value, I'll be releasing material as soon as any are ready.</p></li>\n<li><p>Started working on a tool to simplify my workflow. I can't begin to describe how rewarding it is to create a tool that solves a personal problem. I hate that I didn't do it earlier, but I'm glad I started to with Go. Going to develop it more and will release a post on it later.</p></li>\n<li><p>Other Go related projects are in the works...</p></li>\n</ul>\n\n<h2 id=\"notesonthecode\">Notes on the Code</h2>\n\n<p>Basic operations:</p>\n\n<ul>\n<li><p><strong>Insert(newValue interface{})  error</strong> - Traverses the tree along a route determined by whether the value to be inserted is greater, less than, or equal to the current node's value. Before traversing to a node by invoking the <code>Insert()</code> method on the left or right child, the particular field is checked to see if its value is nil. If so, allocate space for a new node and assign the left/right child to point to it, then copy the new integer to be inserted into the new node's <code>Data</code> field. While an <code>error</code> is returned, there is currently no functionality which checks for any errors. </p></li>\n<li><p><strong>Find(value interface{}) *Node</strong> - Traverses tree in search of a Node's <code>Data</code> field that matches the <code>value</code> argument. Upon success the address of the node is returned, nil is returned otherwise. </p></li>\n<li><p><strong>Delete(value interface{}) *Node</strong> - Recursive method which deletes most nodes by removing pointer references to them. The single use case where this won't happen is with the root node. Removing a root node will simply set its <code>Data</code> field to nil. In this case such a node is considered empty. </p></li>\n<li><p><strong>Height() int</strong> - Recursive method that returns 1 + the maximum value of a call to Height for each of the node's children. If the node is considered empty, 0 is returned. So each node is given a value of 1, and the height is the sum of the tallest 'node trail'.</p></li>\n<li><p><strong>FindMin() int</strong> - Recursive method which returns the smallest integer among the left children of a tree. </p></li>\n<li><p><strong>FindMax() int</strong> - Recursive method which returns the largest value among the right children of a tree.</p></li>\n<li><p><strong>Print()</strong> - Prints the value of each node, traversing the tree in a preorder fashion. </p></li>\n<li><p><strong>min(num1 int, num2 int) int</strong> and <strong>max(num1 int, num2 int) int</strong> - behaves as expected. Naming was kept lowercase to conform to package naming conventions where lowercase functions are not exported. In this case, the practice describes helper functions. </p></li>\n</ul>\n\n<hr />\n\n<ul>\n<li><p>Since a struct cannot be nil, there needs to be some way to determine whether a struct is 'empty'. The data field which stores integers is an empty interface. Since an empty interface can in fact be nil, that's what I checked for. </p></li>\n<li><p>Didnt realize that there were so many different ways Delete() could be written. I made sure to write mine on my own version before observing others. Creating algorithms off the top of my head was fun but time consuming.</p></li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1408937806689,"created_by":1,"updated_at":1409304986981,"updated_by":1,"published_at":1408661520000,"published_by":1,"visibility":"public","mobiledoc":null},{"id":16,"uuid":"acf382fd-8e28-4d38-aa3a-769a24bc3515","title":"Happy Birthday, Dennis Ritchie!","slug":"happy-birthday-dennis-ritchie","markdown":"I would like to take the pleasure of saying happy birthday to [Dennis Ritchie](http://en.wikipedia.org/wiki/Dennis_Ritchie), creator of the [C Programming Language](http://en.wikipedia.org/wiki/C_(programming_language)), the R in the famous and revered [K&R](http://en.wikipedia.org/wiki/The_C_Programming_Language) book, and along with [Ken Thompson](http://en.wikipedia.org/wiki/Ken_Thompson) and others, developer of the [UNIX operating system](http://en.wikipedia.org/wiki/Unix#cite_note-Ritchie-3). \n\nIt's hard for me to explain how C powers the world today. To quote a wired article, [\"Dennis Ritchie: The Shoulders Steve Jobs Stood On\"](http://www.wired.com/2011/10/thedennisritchieeffect/) (a must read), Rob Pike, \"who spent 20 years working across the hall from Ritchie\" mentions:\n\n> “Pretty much everything on the web uses those two things: C and UNIX,” Pike tells Wired. “The browsers are written in C. The UNIX kernel — that pretty much the entire Internet runs on — is written in C. Web servers are written in C, and if they’re not, they’re written in Java or C++, which are C derivatives, or Python or Ruby, which are implemented in C. And all of the network hardware running these programs I can almost guarantee were written in C.\n\n>“It’s really hard to overstate how much of the modern information economy is built on the work Dennis did.”\n\nFor now, Go follows Ruby and Python in that it is currently implemented in C. \n\nDennis' father and uncle also worked at Bell Labs. His brother, Bill Ritchie, is behind [Thinkfun](http://www.thinkfun.com/robotturtles/) which recently released [a board game that teaches preschoolers the basics of computer programming](http://www.wired.com/2014/07/the-75-year-saga-behind-a-game-that-teachers-preschoolers-to-code/).\n\nIf you haven't already, definitely take the time to learn more about him! Heck, write \"Hello, World\" in C, or even just watch this prank by Penn and Teller featuring Rob and Dennis:\n\n<iframe width=\"420\" height=\"315\" src=\"//www.youtube.com/embed/fxMKuv0A6z4\" frameborder=\"0\" allowfullscreen></iframe>\n","html":"<p>I would like to take the pleasure of saying happy birthday to <a href=\"http://en.wikipedia.org/wiki/Dennis_Ritchie\">Dennis Ritchie</a>, creator of the <a href=\"http://en.wikipedia.org/wiki/C_(programming_language)\">C Programming Language</a>, the R in the famous and revered <a href=\"http://en.wikipedia.org/wiki/The_C_Programming_Language\">K&amp;R</a> book, and along with <a href=\"http://en.wikipedia.org/wiki/Ken_Thompson\">Ken Thompson</a> and others, developer of the <a href=\"http://en.wikipedia.org/wiki/Unix#cite_note-Ritchie-3\">UNIX operating system</a>. </p>\n\n<p>It's hard for me to explain how C powers the world today. To quote a wired article, <a href=\"http://www.wired.com/2011/10/thedennisritchieeffect/\">\"Dennis Ritchie: The Shoulders Steve Jobs Stood On\"</a> (a must read), Rob Pike, \"who spent 20 years working across the hall from Ritchie\" mentions:</p>\n\n<blockquote>\n  <p>“Pretty much everything on the web uses those two things: C and UNIX,” Pike tells Wired. “The browsers are written in C. The UNIX kernel — that pretty much the entire Internet runs on — is written in C. Web servers are written in C, and if they’re not, they’re written in Java or C++, which are C derivatives, or Python or Ruby, which are implemented in C. And all of the network hardware running these programs I can almost guarantee were written in C.</p>\n  \n  <p>“It’s really hard to overstate how much of the modern information economy is built on the work Dennis did.”</p>\n</blockquote>\n\n<p>For now, Go follows Ruby and Python in that it is currently implemented in C. </p>\n\n<p>Dennis' father and uncle also worked at Bell Labs. His brother, Bill Ritchie, is behind <a href=\"http://www.thinkfun.com/robotturtles/\">Thinkfun</a> which recently released <a href=\"http://www.wired.com/2014/07/the-75-year-saga-behind-a-game-that-teachers-preschoolers-to-code/\">a board game that teaches preschoolers the basics of computer programming</a>.</p>\n\n<p>If you haven't already, definitely take the time to learn more about him! Heck, write \"Hello, World\" in C, or even just watch this prank by Penn and Teller featuring Rob and Dennis:</p>\n\n<iframe width=\"420\" height=\"315\" src=\"//www.youtube.com/embed/fxMKuv0A6z4\" frameborder=\"0\" allowfullscreen></iframe>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1410233320847,"created_by":1,"updated_at":1410237345649,"updated_by":1,"published_at":1410235603367,"published_by":1,"visibility":"public","mobiledoc":null},{"id":17,"uuid":"771d05f9-2456-44ce-bf37-8b4f8ee52064","title":"It's Been a While!","slug":"its-been-a-while","markdown":"I've taken some time off to focus on my final year of school. Unfortunately that meant being away from Go for quite a while, and man did I miss a lot. \n\nWith my winter break starting some time next week, I'm definitely going to get right back into learning Go and catching up with all that I've missed. \n\nWhile weekly posts have stopped, I've at least been doing something Go related every month, more on that later. Just wanted to make a quick update and let people know that I'm still around. I'm currently working on implementing [Pollard's Rho](http://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm) in Go as an extra credit assignment for my Discrete Mathematics course. There will be a post on it soon!\n","html":"<p>I've taken some time off to focus on my final year of school. Unfortunately that meant being away from Go for quite a while, and man did I miss a lot. </p>\n\n<p>With my winter break starting some time next week, I'm definitely going to get right back into learning Go and catching up with all that I've missed. </p>\n\n<p>While weekly posts have stopped, I've at least been doing something Go related every month, more on that later. Just wanted to make a quick update and let people know that I'm still around. I'm currently working on implementing <a href=\"http://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm\">Pollard's Rho</a> in Go as an extra credit assignment for my Discrete Mathematics course. There will be a post on it soon!</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1418164424195,"created_by":1,"updated_at":1418164424195,"updated_by":1,"published_at":1418164424196,"published_by":1,"visibility":"public","mobiledoc":null},{"id":18,"uuid":"a1031384-dac0-49c5-915b-e34cb346db40","title":"Using the text/template package in Go","slug":"using-the-texttemplate-package-in-go","markdown":"This week I'm working with the [text/template](http://golang.org/pkg/text/template/) package. As the page describes, \"Package template implements data-driven templates for generating textual output.\" \n\nIn a nutshell, a template can be a string or file(s). A template includes `Actions` which are enclosed between `{{` and `}}` brackets. Data is supplied, and the template is executed against it. The result of the text from evaluated actions are usually dependent on the data. \n\nWhile this post aims to convey the usage of the package in simplest terms, templates can be very complex. Evaluated `Actions` can be conditional, templates can be nested, variables and functions can and do exist within `Actions`, the list goes on.\n\n#### The Three Simple Steps\nThe example in this post makes use of one data structure and three methods in the `text/template` package. \n\n1. Create a variable of type `text/template` and name it.\n```\nvar t template.Template = template.New(\"greeting\")\n```\n\n2. Create a text template as a string, use the `Parse` function to supply the template that will be used. \n```\nt.Parse(\"Hello, {{.Name}}! Nice to meet you.\")\n```\n\n3. Execute the template and provide the data structure that the template will be parsed against. The first argument the execute method is where output will be written to and is of type `io.Writer`.\n```\ntype Person struct {\n        Name string \n}\n\nvar p = Person{\"Corey\"}\nt.Execute(os.Stdout, p)\n```\nA working program for the example code above can be found [here](https://play.golang.org/p/Jc5XLiQrtd).\n\n####In practice\n\nThis example is slightly different but is seen more frequently than the example above. Here are the couple of lines in main that produce the output, \"Hello there, Corey!\"\n```\nvar p = Person{\"Corey\"}\nvar t = template.Must(template.New(\"greeting\").Parse(\"Hello there, {{.Name}}!\"))\n\nerr := t.Execute(os.Stdout, p)\nif err != nil { panic(err) } \n```\n\nNotes\n\n- As you can see, the methods can be \"chained\"\n\n- `template.Must` is a wrapper for a function that returns both a pointer to a `template.Template` and an `error`. It panics if the error is non-nil. \n\n- The complete program can be found [here](https://play.golang.org/p/byXetNhX06).\n\n","html":"<p>This week I'm working with the <a href=\"http://golang.org/pkg/text/template/\">text/template</a> package. As the page describes, \"Package template implements data-driven templates for generating textual output.\" </p>\n\n<p>In a nutshell, a template can be a string or file(s). A template includes <code>Actions</code> which are enclosed between <code>{{</code> and <code>}}</code> brackets. Data is supplied, and the template is executed against it. The result of the text from evaluated actions are usually dependent on the data. </p>\n\n<p>While this post aims to convey the usage of the package in simplest terms, templates can be very complex. Evaluated <code>Actions</code> can be conditional, templates can be nested, variables and functions can and do exist within <code>Actions</code>, the list goes on.</p>\n\n<h4 id=\"thethreesimplesteps\">The Three Simple Steps</h4>\n\n<p>The example in this post makes use of one data structure and three methods in the <code>text/template</code> package. </p>\n\n<ol>\n<li>Create a variable of type <code>text/template</code> and name it.  </li>\n</ol>\n\n<pre><code>var t template.Template = template.New(\"greeting\")  \n</code></pre>\n\n<ol>\n<li>Create a text template as a string, use the <code>Parse</code> function to supply the template that will be used.  </li>\n</ol>\n\n<pre><code>t.Parse(\"Hello, {{.Name}}! Nice to meet you.\")  \n</code></pre>\n\n<ol>\n<li>Execute the template and provide the data structure that the template will be parsed against. The first argument the execute method is where output will be written to and is of type <code>io.Writer</code>.  </li>\n</ol>\n\n<pre><code>type Person struct {  \n        Name string \n}\n\nvar p = Person{\"Corey\"}  \nt.Execute(os.Stdout, p)  \n</code></pre>\n\n<p>A working program for the example code above can be found <a href=\"https://play.golang.org/p/Jc5XLiQrtd\">here</a>.</p>\n\n<h4 id=\"inpractice\">In practice</h4>\n\n<p>This example is slightly different but is seen more frequently than the example above. Here are the couple of lines in main that produce the output, \"Hello there, Corey!\"  </p>\n\n<pre><code>var p = Person{\"Corey\"}  \nvar t = template.Must(template.New(\"greeting\").Parse(\"Hello there, {{.Name}}!\"))\n\nerr := t.Execute(os.Stdout, p)  \nif err != nil { panic(err) }  \n</code></pre>\n\n<p>Notes</p>\n\n<ul>\n<li><p>As you can see, the methods can be \"chained\"</p></li>\n<li><p><code>template.Must</code> is a wrapper for a function that returns both a pointer to a <code>template.Template</code> and an <code>error</code>. It panics if the error is non-nil. </p></li>\n<li><p>The complete program can be found <a href=\"https://play.golang.org/p/byXetNhX06\">here</a>.</p></li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1426665754313,"created_by":1,"updated_at":1427560272131,"updated_by":1,"published_at":1426671546804,"published_by":1,"visibility":"public","mobiledoc":null},{"id":19,"uuid":"d55d2cd8-cf54-4b4f-867f-47dd45776950","title":"Golang.Recipes","slug":"introducing-golang-recipes","markdown":"[golang.recipes](http://golang.recipes) which is a resource of Go files that convey examples of Go. My last semester of school was so packed that I only programmed in Go once. Getting back into it was intimidating, but I'm glad I got over the hump. \n\nLearning about so many things in such a short amount of time makes retention difficult. I thought it'd be nice to share some of the examples I've created whenever I learn something new. It would be great to see contributors add their own snippets.\n\nThe project is available on Github [here](https://github.com/Xercoy/Golang-Recipes). Just developing this project alone has taught me so much. I'm not sure how much mileage others will get from it, but I plan to keep on developing the \"Cookbook\" for as long as I am learning something. \n\n######Details\n(I'll be editing this post to add more technical details as I work on things)\n\nThe most notable of the packages used to develop the server include html/template and bufio. Thanks to them, the recipe list is generated automatically. \n\nTo retrieve all of the file names in the recipes directory, I used the `ReadDir` function from the `io/ioutil` package. The recipe names are included on the first line of every file, so all I had to do was read the first line and keep everything minus the comment tokens. \n\nthe `html/template` package is pretty complex, way more than I described it to be in my last post. One nifty thing I had to do was call a method from the templating file.\n\nApologies if this post isn't as thorough on the technical details as usual!\n######Roadmap\n- SSL Support, just as a learning experience.\n- Test support.\n- Recipes are sorted alphabetically, I'm planning on separating them by category soon. \n- Syntax highlighting for recipes!\n- New Pages; a contributors page would be nice.\n- Need to ask permission for Go Playground support.\n- Major renaming and refactoring. Page templates are scattered and recipes should be categorized...","html":"<p><a href=\"http://golang.recipes\">golang.recipes</a> which is a resource of Go files that convey examples of Go. My last semester of school was so packed that I only programmed in Go once. Getting back into it was intimidating, but I'm glad I got over the hump. </p>\n\n<p>Learning about so many things in such a short amount of time makes retention difficult. I thought it'd be nice to share some of the examples I've created whenever I learn something new. It would be great to see contributors add their own snippets.</p>\n\n<p>The project is available on Github <a href=\"https://github.com/Xercoy/Golang-Recipes\">here</a>. Just developing this project alone has taught me so much. I'm not sure how much mileage others will get from it, but I plan to keep on developing the \"Cookbook\" for as long as I am learning something. </p>\n\n<h6 id=\"details\">Details</h6>\n\n<p>(I'll be editing this post to add more technical details as I work on things)</p>\n\n<p>The most notable of the packages used to develop the server include html/template and bufio. Thanks to them, the recipe list is generated automatically. </p>\n\n<p>To retrieve all of the file names in the recipes directory, I used the <code>ReadDir</code> function from the <code>io/ioutil</code> package. The recipe names are included on the first line of every file, so all I had to do was read the first line and keep everything minus the comment tokens. </p>\n\n<p>the <code>html/template</code> package is pretty complex, way more than I described it to be in my last post. One nifty thing I had to do was call a method from the templating file.</p>\n\n<p>Apologies if this post isn't as thorough on the technical details as usual!  </p>\n\n<h6 id=\"roadmap\">Roadmap</h6>\n\n<ul>\n<li>SSL Support, just as a learning experience.</li>\n<li>Test support.</li>\n<li>Recipes are sorted alphabetically, I'm planning on separating them by category soon. </li>\n<li>Syntax highlighting for recipes!</li>\n<li>New Pages; a contributors page would be nice.</li>\n<li>Need to ask permission for Go Playground support.</li>\n<li>Major renaming and refactoring. Page templates are scattered and recipes should be categorized...</li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1427560305134,"created_by":1,"updated_at":1427632074599,"updated_by":1,"published_at":1427562123027,"published_by":1,"visibility":"public","mobiledoc":null},{"id":20,"uuid":"c3d13dc8-b8dd-4fdb-90c7-78d516a0e0d9","title":"Generating Random Numbers","slug":"generating-random-numbers-2","markdown":"####Generating Random Numbers\nThe `time` package is used to generate random numbers and contains a few types: rand, source, and seed. Remember them in that order! \n\n- `seed` is a number that initializes the generator and is of type `int64`\n- `source` contains a list of pseudo-random numbers ranging from 0 to 1<<63 along with the seed that was used to generate the list\n- `rand` is a type that contains a source\n\nThere are two ways to use the package:\n\n##One\n\nThe top level functions in the time package share the same `Seed` which is initialized when the program is started. The default seed is to 1 if it isn't explicitly set. If you need only one `Source` to generate random variables, this is the way to go. \n\nExample:\n\n##Two\n1) Create a Source and provide a Seed.\n2) Create a Rand and provide the Source\n3) Use your Rand to return random numbers from the seed \n\n\n","html":"<h4 id=\"generatingrandomnumbers\">Generating Random Numbers</h4>\n\n<p>The <code>time</code> package is used to generate random numbers and contains a few types: rand, source, and seed. Remember them in that order! </p>\n\n<ul>\n<li><code>seed</code> is a number that initializes the generator and is of type <code>int64</code></li>\n<li><code>source</code> contains a list of pseudo-random numbers ranging from 0 to 1&lt;&lt;63 along with the seed that was used to generate the list</li>\n<li><code>rand</code> is a type that contains a source</li>\n</ul>\n\n<p>There are two ways to use the package:</p>\n\n<h2 id=\"one\">One</h2>\n\n<p>The top level functions in the time package share the same <code>Seed</code> which is initialized when the program is started. The default seed is to 1 if it isn't explicitly set. If you need only one <code>Source</code> to generate random variables, this is the way to go. </p>\n\n<p>Example:</p>\n\n<h2 id=\"two\">Two</h2>\n\n<p>1) Create a Source and provide a Seed. <br />\n2) Create a Rand and provide the Source <br />\n3) Use your Rand to return random numbers from the seed </p>","image":null,"featured":0,"page":0,"status":"draft","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1427684369995,"created_by":1,"updated_at":1427700584657,"updated_by":1,"published_at":null,"published_by":null,"visibility":"public","mobiledoc":null},{"id":21,"uuid":"5dc18ee6-37d5-4d12-bd48-b55a70c52f7d","title":"Golang.Recipes: Server.go","slug":"golang-recipes-server-go","markdown":"","html":"","image":null,"featured":0,"page":0,"status":"draft","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1428614725631,"created_by":1,"updated_at":1428614725631,"updated_by":1,"published_at":null,"published_by":null,"visibility":"public","mobiledoc":null},{"id":22,"uuid":"12d918bc-caf7-4460-bcee-e043930f82b6","title":"Understanding io.Reader and io.Writer Once and For All","slug":"understanding-io-reader-and-io-writer-once-and-for-all","markdown":"io.Reader is the basic interface that implements the read method. \n\nWhat does this mean? It means that any type that implements the read method can be passed around for any code that would requires an io.Reader. \n\n==\n\nbufio.Reader is a Reader that wraps the basic io.Reader AND provides a buffer AND implements its own read method. \n\n== \n\nos.File is a struct that has a Read(), Write(), and Seek() method, so it is an io.Reader. \n\nos.Stdin is a variable that is an open `os.File` that points to stdin. This means that os.Stdin is an io.Reader.\n\nSoooooo\n==\n\n\n\n","html":"<p>io.Reader is the basic interface that implements the read method. </p>\n\n<p>What does this mean? It means that any type that implements the read method can be passed around for any code that would requires an io.Reader. </p>\n\n<p><mark></p>\n\n<p>bufio.Reader is a Reader that wraps the basic io.Reader AND provides a buffer AND implements its own read method. </p>\n\n<p></mark> </p>\n\n<p>os.File is a struct that has a Read(), Write(), and Seek() method, so it is an io.Reader. </p>\n\n<p>os.Stdin is a variable that is an open <code>os.File</code> that points to stdin. This means that os.Stdin is an io.Reader.</p>\n\n<h1 id=\"soooooo\">Soooooo  </h1>","image":null,"featured":0,"page":0,"status":"draft","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1444593965798,"created_by":1,"updated_at":1444595285257,"updated_by":1,"published_at":null,"published_by":null,"visibility":"public","mobiledoc":null},{"id":23,"uuid":"05569bc0-12fe-4fa0-9733-426a3d2cb034","title":"Go's Time Package in a Few Minutes","slug":"the-time-package-in-a-few-minutes","markdown":"```\nHard to believe that March was the last time anything has been published. Since then, I've graduated from school and have been very fortunate enough to land a gig where I get to write in Go everyday. As such, my experience with the language has grown, and I hope to be able to make more frequent posts of higher quality code. Thought it'd be useful to share my learning after spending a lot of time on Go's time package.\n```\n\nThe `time` package makes it really easy for you to:\n\n- Evaluate code runtime\n- Compare dates\n- Interpret and Describe times in different formats.\n\nIn this post, we'll look at snippets of code to see how great the `time` package is. If you'd like to see the examples in full scope (error handling and pretty print), view/run the single main.go file from [Github](https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/gos_time_package_in_a_few_minutes/main.go).\n\nIn addition to basic time information, the time.Time struct contains information on time zone and date.\n\nHere's a block of the common variables used in the following examples:\n```\nvar(\n    // Various times that will be used by the examples.\n\tt1, t2, t3          time.Time\n    \n    // *time.Location representing EST and UTC time zones, respectively. \n    estLoc, utcLoc      *time.Locations\n)\t\n```\nthe variables `estLoc` and `utcLoc` are created using the `LoadLocation()` function, which takes in a string and returns a valid `time.Location` pointer. \n\nA `time.Location` is the primary means of conveying time zone information. There is a zip folder in which valid locations are loaded from, a few valid strings for `LoadLocation()` include `est`, `utc`, `Europe/London`, and `America/New_York`. Take a look at `$GOROOT/lib/time/zoneinfo.zip` for more information.\n\n---\n\n######Example 1: Creating time.Time Objects in Three Different Ways:\n\n**First** - The function `ParseInLocation()` will return a time object based on a string (format specified by the first argument) and a time zone:\n```\nt1, err = time.ParseInLocation(time.Kitchen, \"6:03PM\", estLoc)\nif err != nil {\n   log.Fatalln(err)\n}\n```\n\nAnother function, `Parse()`, which accepts a `time.Format` and a valid string, is similar to `ParseInLocation()`. The two key differences:\n\n- `Parse` will set the default time zone as UTC when it is omitted.\n- `Parse` will match the time zone against the Local location.\n\nIn both situations, `ParseInLocation` will interpret both based on the given time zone.\n\n\n**Second** - `time.Now()` will return time information `time.Time` object based on the runtime environment.\n```\nt2 = time.Now()\n```\n\n**Third** - the `time.Date()` function allows a time object to be created very specifically. The arguments, in order, describe the year, month, day, hour, minute, second, nanosecond, and location:\n```\nt3 = time.Date(2015, 12, 25, 12, 0, 0, 3, utcLoc)\n```\nAs you can see, a `time.Time` object can be very specific or loose upon creation. Here's the output of each time by calling and printing their `String()` method:\n```\nt1 = 0000-01-01 18:03:00 -0500 EST\nt2 = 2015-12-27 21:28:39.175825714 -0500 EST\nt3 = 0200-04-01 00:04:00.000000003 +0000 UTC\n```\n\n---\n\n######Example 2: Comparing Whether Two time.Time objects are equal using the equality operator and the Equal Method:\nHere we create two `time.Time` objects. Note that they indicate different times and time zones.\n```\nt1, err = time.ParseInLocation(time.Kitchen, \"6:03PM\", estLoc)\nif err != nil {\n    log.Fatalln(err)\n}\n\nt2, err = time.ParseInLocation(time.Kitchen, \"11:03PM\", utcLoc)\n```\nNow, if we were to compare the two appropriately:\n```\nif t1 == t2 {\n    fmt.Printf(\"\\nt1 and t2 are equal using `==`.\")\n} else {\n    fmt.Printf(\"\\nt1 and t2 are not equal using `==`.\")\n}\n\nif t1.Equal(t2) {\n    fmt.Printf(\"\\nt1 and t2 are equal using the Equal method.\")\n} else {\n    fmt.Printf(\"\\nt1 and t2 are not equal using the Equal method.\")\n}\n```\nWe can observe one message saying that they are equal while the other describes otherwise: \n```\nt1 and t2 are not equal using `==`.\nt1 and t2 are equal using the Equal method.\n```\nThe equality operator takes time zone into account when comparing a `time.Time` object, so t1 and t2 aren't equal unless both time and time zone are equal.\n\nThe `Equal` method works differently because it is comparing an **instance of time**, which is why t1 and t2 are equal despite having different times and time zones.\n\n---\n\n######Example 3: Comparing Whether One Time is Set Before or After Another:\nCreate two `time.Time` objects, t1 will be created using `time.Now()` while t2 will be created by calling t1's `Add`. The `Add` method takes a `time.Duration` as an argument and appropriately returns a `time.Time`. In this case, t2 is set to a full day after t1:  \n```\n// Get current time and date information.\nt1 = time.Now()\n\n// Assign t2 to the current time and date information + 1 day.\nt2 = t1.Add(time.Duration(24) * time.Hour)\n```\nTo understand how to manipulate a `time.Duration`, it's best to quote the documentation:\n```\nTo count the number of units in a Duration, divide:\n\nsecond := time.Second\nfmt.Print(int64(second/time.Millisecond)) // prints 1000\nTo convert an integer number of units to a Duration, multiply:\n\nseconds := 10\nfmt.Print(time.Duration(seconds)*time.Second) // prints 10s\n```\n\nIn this case I specified 24 hours to describe one day. It would also suffice to provide `Add()` with `time.Duration(1) * time.Day`. Now if we setup output like so:\n```\nif t1.After(t2) {\n    fmt.Printf(\"\\nt1(%s) occurs after t2(%s)\", t1.String(), t2.String())\n} else {\n    fmt.Printf(\"\\nt1(%s) occurs before t2(%s)\", t1.String(), t2.String())\n}\n```\nThe result would be:\n```\nt1(2015-12-27 21:28:39.177133929 -0500 EST) occurs before t2(2015-12-28 21:28:39.177133929 -0500 EST)\n```\nAn equivalent `Before()` method is also available.\n\n---\n\n######Example 4: Representing Times in Different Formats:\n\nIn this example, we create a `time.Time` object and show how it can be represented in multiple formats. First, a date of Xmas 2015 is given to `ParseInLocation`. Note the use of a different format provided to `ParseInLocation()`:\n```\nt1, err = time.ParseInLocation(time.RFC1123, \"Fri, 25 Dec 2015 12:00:00 EST\", estLoc)\n```\n\nNow for the magic:\n```\nfmt.Printf(\"\\nT1 has been set to Xmas day 2015 Eastern Time.\")\n\nfmt.Printf(\"\\nT1 in RFC3339: %s\", t1.Format(time.RFC3339))\n\nfmt.Printf(\"\\nT1 in RFC1123: %s\", t1.Format(time.RFC1123))\n\nfmt.Printf(\"\\nT1 in custom format: %v %v %v, %v\", t1.Weekday().String(), t1.Month().String(), t1.Day(), t1.Year())\n```\n\nOutput:\n```\nT1 has been set to Xmas day 2015 Eastern Time.\nT1 in RFC3339: 2015-12-25T12:00:00-05:00\nT1 in RFC1123: Fri, 25 Dec 2015 12:00:00 EST\nT1 in custom format: Friday December 25, 2015\n```\n\n---\n\n######Example 5: Representing Equivalent Times in Different Time Zones\nt1 is set to Xmas 2015 at noon in EST time zone, and we also create another `*time.Location` specific to this example which represents the time zone in London:\n```\nt1, _ = time.ParseInLocation(time.RFC1123, \"Fri, 25 Dec 2015 12:00:00 EST\", estLoc)\n\nlondonLoc, _ := time.LoadLocation(\"Europe/London\")\n```\nNow to setup the output. In the first print statement we are simply calling t1's `String()` method. \n\nThe interesting part of this example is the second `Printf` statement where we call t1's `In()` method. It takes a `time.Location` as an argument and returns a `time.Time` object with an equivalent time in the given time zone:\n```\nfmt.Printf(\"\\nt1 (set to Xmas 2015 EST at noon): %s\", t1.String())\n\nfmt.Printf(\"\\nt1 equivalent time in London: %s\", t1.In(londonLoc).String())\n```\nThe output:\n```\nt1 (set to Xmas 2015 EST at noon): 2015-12-25 12:00:00 -0500 EST\nt1 equivalent time in London: 2015-12-25 17:00:00 +0000 GMT\n```\n\n---\n\n######Example 6: Timing Code\n\nCreate two different `Time` objects using `time.Now()` before and after the code you'd like to measure the runtime for:\n```\nt1 = time.Now()\ntime.Sleep(time.Duration(3) * time.Second)\nt2 = time.Now()\n```\nTo determine the difference, simply call t2's `Sub()` method and provide t1 as an argument. The result is a `Time` object that describes the difference:\n```\ntDifference := t2.Sub(t1)\nfmt.Printf(\"\\nThe sleep was %s long\", tDifference.String())\n```\nOutput: \n```\nThe sleep was 3.002775829s long\n```\n\n**Alternative:**\n \nDisregard creating a second time completely and use the top level `Since()` function which takes a `time.Time` as an argument and returns a `time.Duration` of the difference:\n \n```\nt1 = time.Now()\ntime.Sleep(time.Duration(3) * time.Second)\nfmt.Printf(\"\\nThe sleep was %s long.\", time.Since(t1).String())\n```\n`Since(t1)` is shorthand for `time.Now().Sub(t1)`\n\n---\n\n###### Additional notes:\n\n- Times can also be parsed via binary or in JSON format (time must be in RFC 3339 format)\n\n- Methods exist on `time.Time` to extract numerical and string values such as time, date, day, and clock information. Similarly, there are methods to extract numerical values of time on a `time.Duration`.\n\n- The `time` package contains a `timer.Timer` and `timer.Ticker`, types which work exactly as their names descrives. There are also other related functions such as `After()` and `Tick()` which involve channels. While useful, I feel that such content is beyond the scope of a few minutes and deserves its own blog post outright. \n\n---\n\nI aimed to make this post as text minimal as possible, hopefully the code brevity was still just as effective. As always I would appreciate any feedback, especially on tweaking the examples or adding new ones. Thanks for reading!","html":"<pre><code>Hard to believe that March was the last time anything has been published. Since then, I've graduated from school and have been very fortunate enough to land a gig where I get to write in Go everyday. As such, my experience with the language has grown, and I hope to be able to make more frequent posts of higher quality code. Thought it'd be useful to share my learning after spending a lot of time on Go's time package.  \n</code></pre>\n\n<p>The <code>time</code> package makes it really easy for you to:</p>\n\n<ul>\n<li>Evaluate code runtime</li>\n<li>Compare dates</li>\n<li>Interpret and Describe times in different formats.</li>\n</ul>\n\n<p>In this post, we'll look at snippets of code to see how great the <code>time</code> package is. If you'd like to see the examples in full scope (error handling and pretty print), view/run the single main.go file from <a href=\"https://github.com/Xercoy/LearnGoWithMe-Code/blob/master/gos_time_package_in_a_few_minutes/main.go\">Github</a>.</p>\n\n<p>In addition to basic time information, the time.Time struct contains information on time zone and date.</p>\n\n<p>Here's a block of the common variables used in the following examples:  </p>\n\n<pre><code>var(  \n    // Various times that will be used by the examples.\n    t1, t2, t3          time.Time\n\n    // *time.Location representing EST and UTC time zones, respectively. \n    estLoc, utcLoc      *time.Locations\n)    \n</code></pre>\n\n<p>the variables <code>estLoc</code> and <code>utcLoc</code> are created using the <code>LoadLocation()</code> function, which takes in a string and returns a valid <code>time.Location</code> pointer. </p>\n\n<p>A <code>time.Location</code> is the primary means of conveying time zone information. There is a zip folder in which valid locations are loaded from, a few valid strings for <code>LoadLocation()</code> include <code>est</code>, <code>utc</code>, <code>Europe/London</code>, and <code>America/New_York</code>. Take a look at <code>$GOROOT/lib/time/zoneinfo.zip</code> for more information.</p>\n\n<hr />\n\n<h6 id=\"example1creatingtimetimeobjectsinthreedifferentways\">Example 1: Creating time.Time Objects in Three Different Ways:</h6>\n\n<p><strong>First</strong> - The function <code>ParseInLocation()</code> will return a time object based on a string (format specified by the first argument) and a time zone:</p>\n\n<pre><code>t1, err = time.ParseInLocation(time.Kitchen, \"6:03PM\", estLoc)  \nif err != nil {  \n   log.Fatalln(err)\n}\n</code></pre>\n\n<p>Another function, <code>Parse()</code>, which accepts a <code>time.Format</code> and a valid string, is similar to <code>ParseInLocation()</code>. The two key differences:</p>\n\n<ul>\n<li><code>Parse</code> will set the default time zone as UTC when it is omitted.</li>\n<li><code>Parse</code> will match the time zone against the Local location.</li>\n</ul>\n\n<p>In both situations, <code>ParseInLocation</code> will interpret both based on the given time zone.</p>\n\n<p><strong>Second</strong> - <code>time.Now()</code> will return time information <code>time.Time</code> object based on the runtime environment.</p>\n\n<pre><code>t2 = time.Now()  \n</code></pre>\n\n<p><strong>Third</strong> - the <code>time.Date()</code> function allows a time object to be created very specifically. The arguments, in order, describe the year, month, day, hour, minute, second, nanosecond, and location:</p>\n\n<pre><code>t3 = time.Date(2015, 12, 25, 12, 0, 0, 3, utcLoc)  \n</code></pre>\n\n<p>As you can see, a <code>time.Time</code> object can be very specific or loose upon creation. Here's the output of each time by calling and printing their <code>String()</code> method:  </p>\n\n<pre><code>t1 = 0000-01-01 18:03:00 -0500 EST  \nt2 = 2015-12-27 21:28:39.175825714 -0500 EST  \nt3 = 0200-04-01 00:04:00.000000003 +0000 UTC  \n</code></pre>\n\n<hr />\n\n<h6 id=\"example2comparingwhethertwotimetimeobjectsareequalusingtheequalityoperatorandtheequalmethod\">Example 2: Comparing Whether Two time.Time objects are equal using the equality operator and the Equal Method:</h6>\n\n<p>Here we create two <code>time.Time</code> objects. Note that they indicate different times and time zones.  </p>\n\n<pre><code>t1, err = time.ParseInLocation(time.Kitchen, \"6:03PM\", estLoc)  \nif err != nil {  \n    log.Fatalln(err)\n}\n\nt2, err = time.ParseInLocation(time.Kitchen, \"11:03PM\", utcLoc)  \n</code></pre>\n\n<p>Now, if we were to compare the two appropriately:  </p>\n\n<pre><code>if t1 == t2 {  \n    fmt.Printf(\"\\nt1 and t2 are equal using `==`.\")\n} else {\n    fmt.Printf(\"\\nt1 and t2 are not equal using `==`.\")\n}\n\nif t1.Equal(t2) {  \n    fmt.Printf(\"\\nt1 and t2 are equal using the Equal method.\")\n} else {\n    fmt.Printf(\"\\nt1 and t2 are not equal using the Equal method.\")\n}\n</code></pre>\n\n<p>We can observe one message saying that they are equal while the other describes otherwise:  </p>\n\n<pre><code>t1 and t2 are not equal using `==`.  \nt1 and t2 are equal using the Equal method.  \n</code></pre>\n\n<p>The equality operator takes time zone into account when comparing a <code>time.Time</code> object, so t1 and t2 aren't equal unless both time and time zone are equal.</p>\n\n<p>The <code>Equal</code> method works differently because it is comparing an <strong>instance of time</strong>, which is why t1 and t2 are equal despite having different times and time zones.</p>\n\n<hr />\n\n<h6 id=\"example3comparingwhetheronetimeissetbeforeorafteranother\">Example 3: Comparing Whether One Time is Set Before or After Another:</h6>\n\n<p>Create two <code>time.Time</code> objects, t1 will be created using <code>time.Now()</code> while t2 will be created by calling t1's <code>Add</code>. The <code>Add</code> method takes a <code>time.Duration</code> as an argument and appropriately returns a <code>time.Time</code>. In this case, t2 is set to a full day after t1:  </p>\n\n<pre><code>// Get current time and date information.\nt1 = time.Now()\n\n// Assign t2 to the current time and date information + 1 day.\nt2 = t1.Add(time.Duration(24) * time.Hour)  \n</code></pre>\n\n<p>To understand how to manipulate a <code>time.Duration</code>, it's best to quote the documentation:  </p>\n\n<pre><code>To count the number of units in a Duration, divide:\n\nsecond := time.Second  \nfmt.Print(int64(second/time.Millisecond)) // prints 1000  \nTo convert an integer number of units to a Duration, multiply:\n\nseconds := 10  \nfmt.Print(time.Duration(seconds)*time.Second) // prints 10s  \n</code></pre>\n\n<p>In this case I specified 24 hours to describe one day. It would also suffice to provide <code>Add()</code> with <code>time.Duration(1) * time.Day</code>. Now if we setup output like so:  </p>\n\n<pre><code>if t1.After(t2) {  \n    fmt.Printf(\"\\nt1(%s) occurs after t2(%s)\", t1.String(), t2.String())\n} else {\n    fmt.Printf(\"\\nt1(%s) occurs before t2(%s)\", t1.String(), t2.String())\n}\n</code></pre>\n\n<p>The result would be:  </p>\n\n<pre><code>t1(2015-12-27 21:28:39.177133929 -0500 EST) occurs before t2(2015-12-28 21:28:39.177133929 -0500 EST)  \n</code></pre>\n\n<p>An equivalent <code>Before()</code> method is also available.</p>\n\n<hr />\n\n<h6 id=\"example4representingtimesindifferentformats\">Example 4: Representing Times in Different Formats:</h6>\n\n<p>In this example, we create a <code>time.Time</code> object and show how it can be represented in multiple formats. First, a date of Xmas 2015 is given to <code>ParseInLocation</code>. Note the use of a different format provided to <code>ParseInLocation()</code>:  </p>\n\n<pre><code>t1, err = time.ParseInLocation(time.RFC1123, \"Fri, 25 Dec 2015 12:00:00 EST\", estLoc)  \n</code></pre>\n\n<p>Now for the magic:  </p>\n\n<pre><code>fmt.Printf(\"\\nT1 has been set to Xmas day 2015 Eastern Time.\")\n\nfmt.Printf(\"\\nT1 in RFC3339: %s\", t1.Format(time.RFC3339))\n\nfmt.Printf(\"\\nT1 in RFC1123: %s\", t1.Format(time.RFC1123))\n\nfmt.Printf(\"\\nT1 in custom format: %v %v %v, %v\", t1.Weekday().String(), t1.Month().String(), t1.Day(), t1.Year())  \n</code></pre>\n\n<p>Output:  </p>\n\n<pre><code>T1 has been set to Xmas day 2015 Eastern Time.  \nT1 in RFC3339: 2015-12-25T12:00:00-05:00  \nT1 in RFC1123: Fri, 25 Dec 2015 12:00:00 EST  \nT1 in custom format: Friday December 25, 2015  \n</code></pre>\n\n<hr />\n\n<h6 id=\"example5representingequivalenttimesindifferenttimezones\">Example 5: Representing Equivalent Times in Different Time Zones</h6>\n\n<p>t1 is set to Xmas 2015 at noon in EST time zone, and we also create another <code>*time.Location</code> specific to this example which represents the time zone in London:  </p>\n\n<pre><code>t1, _ = time.ParseInLocation(time.RFC1123, \"Fri, 25 Dec 2015 12:00:00 EST\", estLoc)\n\nlondonLoc, _ := time.LoadLocation(\"Europe/London\")  \n</code></pre>\n\n<p>Now to setup the output. In the first print statement we are simply calling t1's <code>String()</code> method. </p>\n\n<p>The interesting part of this example is the second <code>Printf</code> statement where we call t1's <code>In()</code> method. It takes a <code>time.Location</code> as an argument and returns a <code>time.Time</code> object with an equivalent time in the given time zone:  </p>\n\n<pre><code>fmt.Printf(\"\\nt1 (set to Xmas 2015 EST at noon): %s\", t1.String())\n\nfmt.Printf(\"\\nt1 equivalent time in London: %s\", t1.In(londonLoc).String())  \n</code></pre>\n\n<p>The output:  </p>\n\n<pre><code>t1 (set to Xmas 2015 EST at noon): 2015-12-25 12:00:00 -0500 EST  \nt1 equivalent time in London: 2015-12-25 17:00:00 +0000 GMT  \n</code></pre>\n\n<hr />\n\n<h6 id=\"example6timingcode\">Example 6: Timing Code</h6>\n\n<p>Create two different <code>Time</code> objects using <code>time.Now()</code> before and after the code you'd like to measure the runtime for:  </p>\n\n<pre><code>t1 = time.Now()  \ntime.Sleep(time.Duration(3) * time.Second)  \nt2 = time.Now()  \n</code></pre>\n\n<p>To determine the difference, simply call t2's <code>Sub()</code> method and provide t1 as an argument. The result is a <code>Time</code> object that describes the difference:  </p>\n\n<pre><code>tDifference := t2.Sub(t1)  \nfmt.Printf(\"\\nThe sleep was %s long\", tDifference.String())  \n</code></pre>\n\n<p>Output:  </p>\n\n<pre><code>The sleep was 3.002775829s long  \n</code></pre>\n\n<p><strong>Alternative:</strong></p>\n\n<p>Disregard creating a second time completely and use the top level <code>Since()</code> function which takes a <code>time.Time</code> as an argument and returns a <code>time.Duration</code> of the difference:</p>\n\n<pre><code>t1 = time.Now()  \ntime.Sleep(time.Duration(3) * time.Second)  \nfmt.Printf(\"\\nThe sleep was %s long.\", time.Since(t1).String())  \n</code></pre>\n\n<p><code>Since(t1)</code> is shorthand for <code>time.Now().Sub(t1)</code></p>\n\n<hr />\n\n<h6 id=\"additionalnotes\">Additional notes:</h6>\n\n<ul>\n<li><p>Times can also be parsed via binary or in JSON format (time must be in RFC 3339 format)</p></li>\n<li><p>Methods exist on <code>time.Time</code> to extract numerical and string values such as time, date, day, and clock information. Similarly, there are methods to extract numerical values of time on a <code>time.Duration</code>.</p></li>\n<li><p>The <code>time</code> package contains a <code>timer.Timer</code> and <code>timer.Ticker</code>, types which work exactly as their names descrives. There are also other related functions such as <code>After()</code> and <code>Tick()</code> which involve channels. While useful, I feel that such content is beyond the scope of a few minutes and deserves its own blog post outright. </p></li>\n</ul>\n\n<hr />\n\n<p>I aimed to make this post as text minimal as possible, hopefully the code brevity was still just as effective. As always I would appreciate any feedback, especially on tweaking the examples or adding new ones. Thanks for reading!</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1451232318120,"created_by":1,"updated_at":1451364948071,"updated_by":1,"published_at":1451356803034,"published_by":1,"visibility":"public","mobiledoc":null},{"id":24,"uuid":"855d9ea1-586b-426e-b45f-146bf3715989","title":"You've been upgraded to the latest version of Ghost","slug":"ghost-0-7","markdown":"You've just upgraded to the latest version of Ghost and we've made a few changes that you should probably know about!\n\n## Woah, why does everything look different?\n\nAfter two years and hundreds of thousands of users, we learned a great deal about what was (and wasn't) working in the old Ghost admin user interface. What you're looking at is Ghost's first major UI refresh, with a strong focus on being more usable and robust all round.\n\n![New Design](https://ghost.org/images/zelda.png)\n\nThe main navigation menu, previously located at the top of your screen, has now moved over to the left. This makes it way easier to work with on mobile devices, and has the added benefit of providing ample space for upcoming features!\n\n## Lost and found: Your old posts\n\nFrom talking to many of you we understand that finding old posts in the admin area was a real pain; so we've added a new magical search bar which lets you quickly find posts for editing, without having to scroll endlessly. Take it for a spin!\n\n![Search](https://ghost.org/images/search.gif)\n\nQuestions? Comments? Send us a tweet [@TryGhost](https://twitter.com/tryghost)\n\nOh, and yes – you can safely delete this draft post!","html":"<p>You've just upgraded to the latest version of Ghost and we've made a few changes that you should probably know about!</p>\n\n<h2 id=\"woahwhydoeseverythinglookdifferent\">Woah, why does everything look different?</h2>\n\n<p>After two years and hundreds of thousands of users, we learned a great deal about what was (and wasn't) working in the old Ghost admin user interface. What you're looking at is Ghost's first major UI refresh, with a strong focus on being more usable and robust all round.</p>\n\n<p><img src=\"https://ghost.org/images/zelda.png\" alt=\"New Design\" /></p>\n\n<p>The main navigation menu, previously located at the top of your screen, has now moved over to the left. This makes it way easier to work with on mobile devices, and has the added benefit of providing ample space for upcoming features!</p>\n\n<h2 id=\"lostandfoundyouroldposts\">Lost and found: Your old posts</h2>\n\n<p>From talking to many of you we understand that finding old posts in the admin area was a real pain; so we've added a new magical search bar which lets you quickly find posts for editing, without having to scroll endlessly. Take it for a spin!</p>\n\n<p><img src=\"https://ghost.org/images/search.gif\" alt=\"Search\" /></p>\n\n<p>Questions? Comments? Send us a tweet <a href=\"https://twitter.com/tryghost\">@TryGhost</a></p>\n\n<p>Oh, and yes – you can safely delete this draft post!</p>","image":null,"featured":0,"page":0,"status":"draft","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1464615785055,"created_by":1,"updated_at":1467515138737,"updated_by":1,"published_at":1464615785054,"published_by":null,"visibility":"public","mobiledoc":null},{"id":25,"uuid":"73537483-bc28-419f-9362-366b6506e332","title":"leap","slug":"leap","markdown":"New things learned:\n\ndeepequal\n\n","html":"<p>New things learned:</p>\n\n<p>deepequal</p>","image":null,"featured":0,"page":0,"status":"draft","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1465562579610,"created_by":1,"updated_at":1465566187260,"updated_by":1,"published_at":null,"published_by":null,"visibility":"public","mobiledoc":null},{"id":26,"uuid":"83ecb91e-3f76-4716-a075-729367a884f8","title":"Create Test Files in Your Temp Directory","slug":"create-test-files-in-your-temp-directory","markdown":"When running tests that require static files/directories to be generated, I used to just create them in the same working directory wherever the `go test` command was executed. It was either that, or hardcoding a path. \n\nNow, I use the `os.TempDir()` function so that file/directory generating tests would be less invasive to an environment.\n\nAs the [docs](https://golang.org/pkg/os/#TempDir) mention about `os.TempDir()`:\n```\nTempDir returns the default directory to use for temporary files.\n```\n\nThe source is also surprisingly simple:\n\n````\nfunc TempDir() string {\n    dir := Getenv(\"TMPDIR\")\n      if dir == \"\" {\n        if runtime.GOOS == \"android\" {\n          dir = \"/data/local/tmp\"\n        } else {\n          dir = \"/tmp\"\n        }\n      }\n    return dir\n}\n````\n\nThis may not be a surprise to many, but I haven't ever really googled this specific question or come across this detail in an article. Finding a function such as `TempDir()` was intuitive after observing more of the common functions in the `os` package.\n\nDon't forget to use the `path/filepath` function `Join()` when manipulating paths. It is OS agnostic, so there's no need to create OS specific append functions.\n\nA few other useful functions of the `os` package include `os.Chdir()`, `os.Chmod()`, and `os.MkDir`. Do take a look at the package summary, there's bound to be something else that's really useful. Cheers!\n\n","html":"<p>When running tests that require static files/directories to be generated, I used to just create them in the same working directory wherever the <code>go test</code> command was executed. It was either that, or hardcoding a path. </p>\n\n<p>Now, I use the <code>os.TempDir()</code> function so that file/directory generating tests would be less invasive to an environment.</p>\n\n<p>As the <a href=\"https://golang.org/pkg/os/#TempDir\">docs</a> mention about <code>os.TempDir()</code>:  </p>\n\n<pre><code>TempDir returns the default directory to use for temporary files.  \n</code></pre>\n\n<p>The source is also surprisingly simple:</p>\n\n<pre><code class=\"language-`\">func TempDir() string {  \n    dir := Getenv(\"TMPDIR\")\n      if dir == \"\" {\n        if runtime.GOOS == \"android\" {\n          dir = \"/data/local/tmp\"\n        } else {\n          dir = \"/tmp\"\n        }\n      }\n    return dir\n}\n</code></pre>\n\n<p>`</p>\n\n<p>This may not be a surprise to many, but I haven't ever really googled this specific question or come across this detail in an article. Finding a function such as <code>TempDir()</code> was intuitive after observing more of the common functions in the <code>os</code> package.</p>\n\n<p>Don't forget to use the <code>path/filepath</code> function <code>Join()</code> when manipulating paths. It is OS agnostic, so there's no need to create OS specific append functions.</p>\n\n<p>A few other useful functions of the <code>os</code> package include <code>os.Chdir()</code>, <code>os.Chmod()</code>, and <code>os.MkDir</code>. Do take a look at the package summary, there's bound to be something else that's really useful. Cheers!</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1467515302309,"created_by":1,"updated_at":1467517762629,"updated_by":1,"published_at":1467517762630,"published_by":1,"visibility":"public","mobiledoc":null},{"id":27,"uuid":"6a1bbbba-cc93-4d7e-980e-88fe06dd7fcf","title":"Randomization in Go 1.6","slug":"randomization-in-go-1-6","markdown":"Of the many changes that came in Go 1.6, one of the most useful additions concerns randomization.\n\nThe `rand` package adds a method called `Read` and an equivalent function for the default `rand.Source`. I actually didn't notice this was an addition in 1.6 until I attempted to compile some code on 1.5 which included a call to `Read`. Observe the function's signature and description:\n```\nfunc Read(p []byte) (n int, err error)\n\nRead generates len(p) random bytes from the default Source and writes them into p. It always returns len(p) and a nil error.\n```\n\nFirst, let's assume that we live in a world where errors don't exist (for simplicity). Now, we could create a byte slice of a desired size and populate it with random values like so :\n```\nrandomContent := make([]byte, 100)\n\n_,_ := rand.Read(randomContent)\n```\n\nIn the above example, every element of the byte slice `randomContent` has been filled with random values.\n\nSince we don't live in a world where errors don't exist, let's view what a more realistic way of generating a randomized byte slice]:\n```\n// Provide a different Seed value at every execution to ensure \"randomness\".\nrand.Seed(time.Now().UnixNano())\n\n// Create a byte slice of 100 elements.\nrandomContent := make([]byte, 100)\n\n// Read random values into the slice.\n_, _ := rand.Read(randomContent)\n```\n\n(Notice that I used a blank identifier for both return values of the function. While it isn't terribly important, see the next section for an explanation...)\n\nI've never had to generate a random byte slice before 1.6, but I'd imagine that there'd be a loop involved where each iteration involves assigning a random value to every element. Happy coding!\n\n===\n\n## Why the Blank Identifiers?\n\nThe description of `Read` mentioned that it, \"will always return the len(p) and a nil error... That kind of bugged me so I decided to look at at the source:\n```\nfunc (r *Rand) Read(p []byte) (n int, err error) {\n       for i := 0; i < len(p); i += 7 {\n               val := r.src.Int63()\n               for j := 0; i+j < len(p) && j < 7; j++ {\n                       p[i+j] = byte(val)\n                       val >>= 8\n               }\n       }\n       return len(p), nil\n}\n```\n\nAs you can see, the only return statement in the method definition includes the length of the slice arg and nil. \n\nWhile disregarding the return values might be valid, there should probably still be code that handles them.\n### Why?\n\nRecall that the number one rule is to never break backwards compatibility. Also, the style of similarly functioning methods and functions in other packages (Read/Write) return the exact same two bits of information.\n\nWith this in mind, it makes sense that there should be code to check the return values in the event that future changes to the algorithm may produce non nil errors, or read a number of bytes that may differ from the length of the argument slice.\n\nHave another opinion? Have you seen this before in other packages? Let me know! Thanks. \n\n","html":"<p>Of the many changes that came in Go 1.6, one of the most useful additions concerns randomization.</p>\n\n<p>The <code>rand</code> package adds a method called <code>Read</code> and an equivalent function for the default <code>rand.Source</code>. I actually didn't notice this was an addition in 1.6 until I attempted to compile some code on 1.5 which included a call to <code>Read</code>. Observe the function's signature and description:  </p>\n\n<pre><code>func Read(p []byte) (n int, err error)\n\nRead generates len(p) random bytes from the default Source and writes them into p. It always returns len(p) and a nil error.  \n</code></pre>\n\n<p>First, let's assume that we live in a world where errors don't exist (for simplicity). Now, we could create a byte slice of a desired size and populate it with random values like so :  </p>\n\n<pre><code>randomContent := make([]byte, 100)\n\n_,_ := rand.Read(randomContent)  \n</code></pre>\n\n<p>In the above example, every element of the byte slice <code>randomContent</code> has been filled with random values.</p>\n\n<p>Since we don't live in a world where errors don't exist, let's view what a more realistic way of generating a randomized byte slice]:  </p>\n\n<pre><code>// Provide a different Seed value at every execution to ensure \"randomness\".\nrand.Seed(time.Now().UnixNano())\n\n// Create a byte slice of 100 elements.\nrandomContent := make([]byte, 100)\n\n// Read random values into the slice.\n_, _ := rand.Read(randomContent)  \n</code></pre>\n\n<p>(Notice that I used a blank identifier for both return values of the function. While it isn't terribly important, see the next section for an explanation...)</p>\n\n<p>I've never had to generate a random byte slice before 1.6, but I'd imagine that there'd be a loop involved where each iteration involves assigning a random value to every element. Happy coding!</p>\n\n<p>===</p>\n\n<h2 id=\"whytheblankidentifiers\">Why the Blank Identifiers?</h2>\n\n<p>The description of <code>Read</code> mentioned that it, \"will always return the len(p) and a nil error... That kind of bugged me so I decided to look at at the source:  </p>\n\n<pre><code>func (r *Rand) Read(p []byte) (n int, err error) {  \n       for i := 0; i &lt; len(p); i += 7 {\n               val := r.src.Int63()\n               for j := 0; i+j &lt; len(p) &amp;&amp; j &lt; 7; j++ {\n                       p[i+j] = byte(val)\n                       val &gt;&gt;= 8\n               }\n       }\n       return len(p), nil\n}\n</code></pre>\n\n<p>As you can see, the only return statement in the method definition includes the length of the slice arg and nil. </p>\n\n<p>While disregarding the return values might be valid, there should probably still be code that handles them.  </p>\n\n<h3 id=\"why\">Why?</h3>\n\n<p>Recall that the number one rule is to never break backwards compatibility. Also, the style of similarly functioning methods and functions in other packages (Read/Write) return the exact same two bits of information.</p>\n\n<p>With this in mind, it makes sense that there should be code to check the return values in the event that future changes to the algorithm may produce non nil errors, or read a number of bytes that may differ from the length of the argument slice.</p>\n\n<p>Have another opinion? Have you seen this before in other packages? Let me know! Thanks. </p>","image":null,"featured":0,"page":0,"status":"draft","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1467527824653,"created_by":1,"updated_at":1467564707435,"updated_by":1,"published_at":null,"published_by":null,"visibility":"public","mobiledoc":null}],"users":[{"id":1,"uuid":"379d1141-b7fb-4a7e-bd99-c537b3098104","name":"Corey Prak","slug":"corey-prak","password":"$2a$10$HJJAm.nEKAmKcxuM95yXSO/w6Z9RHvYP3XH/5t5R7CAwRsHJrOZz.","email":"corey.prak@gmail.com","image":"//www.gravatar.com/avatar/62e84c3b628766a4aa623766640f480f?d=404","cover":null,"bio":"Always learning, increasingly doing, hopelessly unorganized. Find me on Twitter @coreyprak or shoot me an email, corey@prak.me.","website":"http://corey.prak.me","location":"Boston, MA","accessibility":null,"status":"active","language":"en_US","meta_title":null,"meta_description":null,"last_login":1467682402257,"created_at":1402731012454,"created_by":1,"updated_at":1467682402257,"updated_by":1,"tour":null,"visibility":"public","facebook":null,"twitter":null}],"roles":[{"id":1,"uuid":"6aeeb6dc-dbf4-4e03-b0f4-1f50083b614d","name":"Administrator","description":"Administrators","created_at":1389624432955,"created_by":1,"updated_at":1389624432955,"updated_by":1},{"id":2,"uuid":"6f182850-089b-4f40-8fc0-f682c93b18fb","name":"Editor","description":"Editors","created_at":1389624432959,"created_by":1,"updated_at":1389624432959,"updated_by":1},{"id":3,"uuid":"61611efc-195f-4d9f-9e24-c9946d989bc4","name":"Author","description":"Authors","created_at":1389624432965,"created_by":1,"updated_at":1389624432965,"updated_by":1},{"id":4,"uuid":"bc4ba048-6401-42d5-8916-494642deb7bf","name":"Owner","description":"Blog Owner","created_at":1420015330817,"created_by":1,"updated_at":1420015330817,"updated_by":1}],"roles_users":[{"id":1,"role_id":4,"user_id":1}],"permissions":[{"id":4,"uuid":"a1ff9b2e-30f0-4ad8-978f-f132334b5294","name":"Export database","object_type":"db","action_type":"exportContent","object_id":null,"created_at":1420015330820,"created_by":1,"updated_at":1420015330820,"updated_by":1},{"id":5,"uuid":"ddcc0f19-c16b-4cc9-81a1-9746e0336b98","name":"Import database","object_type":"db","action_type":"importContent","object_id":null,"created_at":1420015330837,"created_by":1,"updated_at":1420015330837,"updated_by":1},{"id":6,"uuid":"21abfb40-d68e-4395-8ddc-66d9a238ca9f","name":"Delete all content","object_type":"db","action_type":"deleteAllContent","object_id":null,"created_at":1420015330854,"created_by":1,"updated_at":1420015330854,"updated_by":1},{"id":7,"uuid":"9bbcb08d-04ea-4cef-9f42-05abafbaeb2f","name":"Send mail","object_type":"mail","action_type":"send","object_id":null,"created_at":1420015330867,"created_by":1,"updated_at":1420015330867,"updated_by":1},{"id":8,"uuid":"09092a81-8d00-4cb6-8c62-4fb9a5c023dc","name":"Browse notifications","object_type":"notification","action_type":"browse","object_id":null,"created_at":1420015330875,"created_by":1,"updated_at":1420015330875,"updated_by":1},{"id":9,"uuid":"418503d4-1ab2-4fb5-96ef-6cd4d510ead0","name":"Add notifications","object_type":"notification","action_type":"add","object_id":null,"created_at":1420015330879,"created_by":1,"updated_at":1420015330879,"updated_by":1},{"id":10,"uuid":"e2aa441c-2f07-413f-a113-59a35a31231b","name":"Delete notifications","object_type":"notification","action_type":"destroy","object_id":null,"created_at":1420015330882,"created_by":1,"updated_at":1420015330882,"updated_by":1},{"id":11,"uuid":"ae94cd36-2f75-4757-8612-49990564ac8b","name":"Browse posts","object_type":"post","action_type":"browse","object_id":null,"created_at":1420015330890,"created_by":1,"updated_at":1420015330890,"updated_by":1},{"id":12,"uuid":"bb2a3673-15ff-4db5-9784-6f321b68cd03","name":"Read posts","object_type":"post","action_type":"read","object_id":null,"created_at":1420015330895,"created_by":1,"updated_at":1420015330895,"updated_by":1},{"id":13,"uuid":"1ce8f944-7b8d-4e15-8219-83b1f50e3b73","name":"Edit posts","object_type":"post","action_type":"edit","object_id":null,"created_at":1420015330899,"created_by":1,"updated_at":1420015330899,"updated_by":1},{"id":14,"uuid":"bfa826ac-4628-4634-9b56-11712fa06335","name":"Add posts","object_type":"post","action_type":"add","object_id":null,"created_at":1420015330903,"created_by":1,"updated_at":1420015330903,"updated_by":1},{"id":15,"uuid":"14fa0c60-b0df-404d-bdfd-e2c102846733","name":"Delete posts","object_type":"post","action_type":"destroy","object_id":null,"created_at":1420015330907,"created_by":1,"updated_at":1420015330907,"updated_by":1},{"id":16,"uuid":"78c51e33-957d-47ff-ab6e-efa78e3beeea","name":"Browse settings","object_type":"setting","action_type":"browse","object_id":null,"created_at":1420015330911,"created_by":1,"updated_at":1420015330911,"updated_by":1},{"id":17,"uuid":"0202b4c7-5717-4f26-838b-0c1487e3b8eb","name":"Read settings","object_type":"setting","action_type":"read","object_id":null,"created_at":1420015330917,"created_by":1,"updated_at":1420015330917,"updated_by":1},{"id":18,"uuid":"708c2b23-39ce-4cb0-b0b1-8b5bcb1a6100","name":"Edit settings","object_type":"setting","action_type":"edit","object_id":null,"created_at":1420015330921,"created_by":1,"updated_at":1420015330921,"updated_by":1},{"id":19,"uuid":"36850087-fe1e-46a1-9050-d76efc6b7052","name":"Generate slugs","object_type":"slug","action_type":"generate","object_id":null,"created_at":1420015330926,"created_by":1,"updated_at":1420015330926,"updated_by":1},{"id":20,"uuid":"e5575e6b-be02-4f26-bf07-e9a242abe21a","name":"Browse tags","object_type":"tag","action_type":"browse","object_id":null,"created_at":1420015330935,"created_by":1,"updated_at":1420015330935,"updated_by":1},{"id":21,"uuid":"48e3bb60-0516-432e-a501-9178df736e3c","name":"Read tags","object_type":"tag","action_type":"read","object_id":null,"created_at":1420015330940,"created_by":1,"updated_at":1420015330940,"updated_by":1},{"id":22,"uuid":"861c7f03-21ad-4c79-8eba-3a2d9d65852d","name":"Edit tags","object_type":"tag","action_type":"edit","object_id":null,"created_at":1420015330944,"created_by":1,"updated_at":1420015330944,"updated_by":1},{"id":23,"uuid":"f71ee275-14c0-4694-aad2-43a3e727de17","name":"Add tags","object_type":"tag","action_type":"add","object_id":null,"created_at":1420015330951,"created_by":1,"updated_at":1420015330951,"updated_by":1},{"id":24,"uuid":"3481e956-264c-4b56-a19a-692c19c84f87","name":"Delete tags","object_type":"tag","action_type":"destroy","object_id":null,"created_at":1420015330954,"created_by":1,"updated_at":1420015330954,"updated_by":1},{"id":25,"uuid":"cab1a1f7-fe47-462c-8082-9937a2025cee","name":"Browse themes","object_type":"theme","action_type":"browse","object_id":null,"created_at":1420015330957,"created_by":1,"updated_at":1420015330957,"updated_by":1},{"id":26,"uuid":"b6c37b12-2ac4-4f88-9b25-27514dbe47a2","name":"Edit themes","object_type":"theme","action_type":"edit","object_id":null,"created_at":1420015330961,"created_by":1,"updated_at":1420015330961,"updated_by":1},{"id":27,"uuid":"192af505-5e46-49ca-b6c5-cc7ecf9d401c","name":"Browse users","object_type":"user","action_type":"browse","object_id":null,"created_at":1420015330967,"created_by":1,"updated_at":1420015330967,"updated_by":1},{"id":28,"uuid":"26899453-49c2-423a-a08e-d4833fffb99f","name":"Read users","object_type":"user","action_type":"read","object_id":null,"created_at":1420015330971,"created_by":1,"updated_at":1420015330971,"updated_by":1},{"id":29,"uuid":"62dcc352-20ce-4c91-b6d2-25bb9c416e95","name":"Edit users","object_type":"user","action_type":"edit","object_id":null,"created_at":1420015330974,"created_by":1,"updated_at":1420015330974,"updated_by":1},{"id":30,"uuid":"797fe136-813a-4ac9-b908-31256084991d","name":"Add users","object_type":"user","action_type":"add","object_id":null,"created_at":1420015330981,"created_by":1,"updated_at":1420015330981,"updated_by":1},{"id":31,"uuid":"47f01579-7c8b-4ad6-bd53-b661a7f943da","name":"Delete users","object_type":"user","action_type":"destroy","object_id":null,"created_at":1420015330985,"created_by":1,"updated_at":1420015330985,"updated_by":1},{"id":32,"uuid":"79e57c28-0353-43b3-8bf6-89fa9eea810c","name":"Assign a role","object_type":"role","action_type":"assign","object_id":null,"created_at":1420015330989,"created_by":1,"updated_at":1420015330989,"updated_by":1},{"id":33,"uuid":"5982011a-ff45-4772-87d8-d26623049899","name":"Browse roles","object_type":"role","action_type":"browse","object_id":null,"created_at":1420015330999,"created_by":1,"updated_at":1420015330999,"updated_by":1},{"id":34,"uuid":"97337f02-9c77-49a8-91ac-dc4b6e66fd26","name":"Browse clients","object_type":"client","action_type":"browse","object_id":null,"created_at":1464615785161,"created_by":1,"updated_at":1464615785161,"updated_by":1},{"id":35,"uuid":"a7a4cc52-2167-40a2-a56f-650a830ab82c","name":"Read clients","object_type":"client","action_type":"read","object_id":null,"created_at":1464615785202,"created_by":1,"updated_at":1464615785202,"updated_by":1},{"id":36,"uuid":"95bcbe0b-eabf-405a-be99-ae5fd61587c0","name":"Edit clients","object_type":"client","action_type":"edit","object_id":null,"created_at":1464615785248,"created_by":1,"updated_at":1464615785248,"updated_by":1},{"id":37,"uuid":"da5b1485-760c-4729-b3e9-3c565a59dbdd","name":"Add clients","object_type":"client","action_type":"add","object_id":null,"created_at":1464615785265,"created_by":1,"updated_at":1464615785265,"updated_by":1},{"id":38,"uuid":"08d426fd-2eba-40cd-8324-21e3ac08f664","name":"Delete clients","object_type":"client","action_type":"destroy","object_id":null,"created_at":1464615785280,"created_by":1,"updated_at":1464615785280,"updated_by":1},{"id":39,"uuid":"13733d7b-30a4-4776-a83f-22891eb7d576","name":"Browse subscribers","object_type":"subscriber","action_type":"browse","object_id":null,"created_at":1464615785509,"created_by":1,"updated_at":1464615785509,"updated_by":1},{"id":40,"uuid":"905e3f18-d41a-4a8e-a616-f1878d9ada14","name":"Read subscribers","object_type":"subscriber","action_type":"read","object_id":null,"created_at":1464615785522,"created_by":1,"updated_at":1464615785522,"updated_by":1},{"id":41,"uuid":"58b9826c-381f-42b7-9130-ed43e5fa0ac3","name":"Edit subscribers","object_type":"subscriber","action_type":"edit","object_id":null,"created_at":1464615785539,"created_by":1,"updated_at":1464615785539,"updated_by":1},{"id":42,"uuid":"044075a8-ea0a-412f-b683-d2facfbd7f7b","name":"Add subscribers","object_type":"subscriber","action_type":"add","object_id":null,"created_at":1464615785550,"created_by":1,"updated_at":1464615785550,"updated_by":1},{"id":43,"uuid":"66343248-b7af-4dc9-a45d-3c63afe9de69","name":"Delete subscribers","object_type":"subscriber","action_type":"destroy","object_id":null,"created_at":1464615785559,"created_by":1,"updated_at":1464615785559,"updated_by":1}],"permissions_users":[],"permissions_roles":[{"id":4,"role_id":1,"permission_id":4},{"id":5,"role_id":1,"permission_id":5},{"id":6,"role_id":1,"permission_id":6},{"id":7,"role_id":1,"permission_id":7},{"id":8,"role_id":1,"permission_id":8},{"id":9,"role_id":1,"permission_id":9},{"id":10,"role_id":1,"permission_id":10},{"id":11,"role_id":1,"permission_id":11},{"id":12,"role_id":1,"permission_id":12},{"id":13,"role_id":1,"permission_id":13},{"id":14,"role_id":1,"permission_id":14},{"id":15,"role_id":1,"permission_id":15},{"id":16,"role_id":1,"permission_id":16},{"id":17,"role_id":1,"permission_id":17},{"id":18,"role_id":1,"permission_id":18},{"id":19,"role_id":1,"permission_id":19},{"id":20,"role_id":1,"permission_id":20},{"id":21,"role_id":1,"permission_id":21},{"id":22,"role_id":1,"permission_id":22},{"id":23,"role_id":1,"permission_id":23},{"id":24,"role_id":1,"permission_id":24},{"id":25,"role_id":1,"permission_id":25},{"id":26,"role_id":1,"permission_id":26},{"id":27,"role_id":1,"permission_id":27},{"id":28,"role_id":1,"permission_id":28},{"id":29,"role_id":1,"permission_id":29},{"id":30,"role_id":1,"permission_id":30},{"id":31,"role_id":1,"permission_id":31},{"id":32,"role_id":1,"permission_id":32},{"id":33,"role_id":1,"permission_id":33},{"id":34,"role_id":2,"permission_id":11},{"id":35,"role_id":2,"permission_id":12},{"id":36,"role_id":2,"permission_id":13},{"id":37,"role_id":2,"permission_id":14},{"id":38,"role_id":2,"permission_id":15},{"id":39,"role_id":2,"permission_id":16},{"id":40,"role_id":2,"permission_id":17},{"id":41,"role_id":2,"permission_id":19},{"id":42,"role_id":2,"permission_id":20},{"id":43,"role_id":2,"permission_id":21},{"id":44,"role_id":2,"permission_id":22},{"id":45,"role_id":2,"permission_id":23},{"id":46,"role_id":2,"permission_id":24},{"id":47,"role_id":2,"permission_id":27},{"id":48,"role_id":2,"permission_id":28},{"id":49,"role_id":2,"permission_id":29},{"id":50,"role_id":2,"permission_id":30},{"id":51,"role_id":2,"permission_id":31},{"id":52,"role_id":2,"permission_id":32},{"id":53,"role_id":2,"permission_id":33},{"id":54,"role_id":3,"permission_id":11},{"id":55,"role_id":3,"permission_id":12},{"id":56,"role_id":3,"permission_id":14},{"id":57,"role_id":3,"permission_id":16},{"id":58,"role_id":3,"permission_id":17},{"id":59,"role_id":3,"permission_id":19},{"id":60,"role_id":3,"permission_id":20},{"id":61,"role_id":3,"permission_id":21},{"id":62,"role_id":3,"permission_id":23},{"id":63,"role_id":3,"permission_id":27},{"id":64,"role_id":3,"permission_id":28},{"id":65,"role_id":3,"permission_id":33},{"id":66,"role_id":1,"permission_id":34},{"id":67,"role_id":1,"permission_id":35},{"id":68,"role_id":1,"permission_id":36},{"id":69,"role_id":1,"permission_id":37},{"id":70,"role_id":1,"permission_id":38},{"id":71,"role_id":2,"permission_id":34},{"id":72,"role_id":2,"permission_id":35},{"id":73,"role_id":2,"permission_id":36},{"id":74,"role_id":2,"permission_id":37},{"id":75,"role_id":2,"permission_id":38},{"id":76,"role_id":3,"permission_id":34},{"id":77,"role_id":3,"permission_id":35},{"id":78,"role_id":3,"permission_id":36},{"id":79,"role_id":3,"permission_id":37},{"id":80,"role_id":3,"permission_id":38},{"id":81,"role_id":1,"permission_id":39},{"id":82,"role_id":1,"permission_id":40},{"id":83,"role_id":1,"permission_id":41},{"id":84,"role_id":1,"permission_id":42},{"id":85,"role_id":1,"permission_id":43},{"id":86,"role_id":2,"permission_id":42},{"id":87,"role_id":3,"permission_id":42}],"settings":[{"id":1,"uuid":"31f03801-a9a9-49d3-b2a1-277c3f2343e8","key":"databaseVersion","value":"005","type":"core","created_at":1389624432989,"created_by":1,"updated_at":1389624432989,"updated_by":1},{"id":2,"uuid":"159925ed-ee76-4785-a29e-8f3bdbf28a6f","key":"dbHash","value":"60e54b73-7f1d-4f8d-99f0-e0e935f2e97f","type":"core","created_at":1389624432990,"created_by":1,"updated_at":1389624433125,"updated_by":1},{"id":3,"uuid":"bab504b1-05a4-43e6-8f63-1d9f9d783919","key":"nextUpdateCheck","value":"1467768789","type":"core","created_at":1389624432990,"created_by":1,"updated_at":1467682389481,"updated_by":1},{"id":4,"uuid":"384ecadb-2923-4d3e-9cb8-5d2f02d0b420","key":"displayUpdateNotification","value":"0.5.0","type":"core","created_at":1389624432990,"created_by":1,"updated_at":1467682389484,"updated_by":1},{"id":5,"uuid":"6ed76b6e-9872-4fe4-bcf5-cfb689a23087","key":"title","value":"Learn Go With Me","type":"blog","created_at":1389624432991,"created_by":1,"updated_at":1464650091266,"updated_by":1},{"id":6,"uuid":"e42c1cf1-869d-4db1-b759-513131dd9c1a","key":"description","value":"My ventures in Go.","type":"blog","created_at":1389624432991,"created_by":1,"updated_at":1464650091277,"updated_by":1},{"id":7,"uuid":"cf5dd68c-83be-4fae-ac10-01e13f7f0c38","key":"email","value":"corey.prak@gmail.com","type":"blog","created_at":1389624432991,"created_by":1,"updated_at":1420037405288,"updated_by":1},{"id":8,"uuid":"9d293f43-9f16-40b3-996c-2dffbf454666","key":"logo","value":"","type":"blog","created_at":1389624432992,"created_by":1,"updated_at":1464650091284,"updated_by":1},{"id":9,"uuid":"c16a41e3-e085-43ee-8c4c-3e36e63694ed","key":"cover","value":"","type":"blog","created_at":1389624432994,"created_by":1,"updated_at":1464650091296,"updated_by":1},{"id":10,"uuid":"dd31f747-78c7-433a-8f0e-de64ed8adc3e","key":"defaultLang","value":"en_US","type":"blog","created_at":1389624432994,"created_by":1,"updated_at":1464650091302,"updated_by":1},{"id":11,"uuid":"b65fdc23-8ef0-4e00-9bfa-1060ac346824","key":"postsPerPage","value":"6","type":"blog","created_at":1389624432994,"created_by":1,"updated_at":1464650091309,"updated_by":1},{"id":12,"uuid":"5177cc06-6adf-4710-bae0-cd0ad2311aeb","key":"forceI18n","value":"true","type":"blog","created_at":1389624432995,"created_by":1,"updated_at":1464650091317,"updated_by":1},{"id":13,"uuid":"77486117-12bf-43e0-8428-94ae1e880513","key":"permalinks","value":"/:slug/","type":"blog","created_at":1389624432995,"created_by":1,"updated_at":1464650091324,"updated_by":1},{"id":14,"uuid":"b0811c68-a2db-4fa8-94fb-f4740c0d8999","key":"activeTheme","value":"casper","type":"theme","created_at":1389624432996,"created_by":1,"updated_at":1464650091332,"updated_by":1},{"id":15,"uuid":"c3924706-25b4-43bd-bf0e-92ef580eb022","key":"activePlugins","value":"[]","type":"plugin","created_at":1389624432996,"created_by":1,"updated_at":1389624432996,"updated_by":1},{"id":16,"uuid":"4e67a480-bcda-4c3a-852d-3837a2776dbb","key":"installedPlugins","value":"[]","type":"plugin","created_at":1389624433003,"created_by":1,"updated_at":1389695119351,"updated_by":1},{"id":17,"uuid":"420369e2-f631-472c-814b-4c33852dc950","key":"activeApps","value":"[]","type":"app","created_at":1395864113253,"created_by":1,"updated_at":1404857263745,"updated_by":1},{"id":18,"uuid":"c930f2c7-387a-440e-bc1e-1bc4ea8f123d","key":"installedApps","value":"[]","type":"app","created_at":1395864113254,"created_by":1,"updated_at":1467682435207,"updated_by":1},{"id":19,"uuid":"4f627429-2213-4bb2-9912-432ff674ea77","key":"ghost_head","value":"","type":"blog","created_at":1420015331223,"created_by":1,"updated_at":1464650091339,"updated_by":1},{"id":20,"uuid":"bd51eb98-8a74-445c-83a9-b957fc222df5","key":"ghost_foot","value":"<!-- You can safely delete this line if your theme does not require jQuery -->\n<script type=\"text/javascript\" src=\"https://code.jquery.com/jquery-1.11.3.min.js\"></script>\n\n","type":"blog","created_at":1420015331225,"created_by":1,"updated_at":1464650091344,"updated_by":1},{"id":21,"uuid":"5bdb9d11-8213-4bf4-bd9e-f861aa8757dd","key":"facebook","value":"","type":"blog","created_at":1464615784652,"created_by":1,"updated_at":1464650091351,"updated_by":1},{"id":22,"uuid":"b7c4080d-c836-45e3-98c7-4aabe2e02f0c","key":"twitter","value":"","type":"blog","created_at":1464615784653,"created_by":1,"updated_at":1464650091358,"updated_by":1},{"id":23,"uuid":"95515056-566f-445d-b50e-183a635c9e6d","key":"labs","value":"{}","type":"blog","created_at":1464615784653,"created_by":1,"updated_at":1464650091364,"updated_by":1},{"id":24,"uuid":"a57a8e6c-02d4-47c1-a1cf-dd90f41425b8","key":"navigation","value":"[{\"label\":\"Home\",\"url\":\"/\"}]","type":"blog","created_at":1464615784655,"created_by":1,"updated_at":1464650091371,"updated_by":1},{"id":25,"uuid":"284964d3-3e66-4b2a-a5f1-72e77b68346a","key":"slack","value":"[{\"url\":\"\"}]","type":"blog","created_at":1464615784656,"created_by":1,"updated_at":1464650091407,"updated_by":1},{"id":26,"uuid":"2461d1a7-7839-45ab-bf14-af215525adc4","key":"isPrivate","value":"false","type":"private","created_at":1464615784657,"created_by":1,"updated_at":1464650091378,"updated_by":1},{"id":27,"uuid":"e7df5fc5-0f7d-4dc2-9881-3e4460799dd2","key":"password","value":"","type":"private","created_at":1464615784657,"created_by":1,"updated_at":1464650091389,"updated_by":1}],"posts_tags":[{"id":2,"post_id":2,"tag_id":2,"sort_order":0},{"id":3,"post_id":12,"tag_id":3,"sort_order":0},{"id":4,"post_id":12,"tag_id":4,"sort_order":1},{"id":5,"post_id":12,"tag_id":5,"sort_order":2},{"id":6,"post_id":12,"tag_id":6,"sort_order":3}],"permissions_apps":[],"apps":[],"app_settings":[],"app_fields":[],"tags":[{"id":1,"uuid":"86e1b250-a591-46de-adc3-82ed34629c18","name":"Getting Started","slug":"getting-started","description":null,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1389624432950,"created_by":1,"updated_at":1389624432950,"updated_by":1,"image":null,"visibility":"public"},{"id":2,"uuid":"eacc1115-bf8f-41df-a842-86f64e3500bb","name":"introduction","slug":"introduction","description":null,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1402847102801,"created_by":1,"updated_at":1402847102801,"updated_by":1,"image":null,"visibility":"public"},{"id":3,"uuid":"0487cb2d-5f67-49cc-b0ec-886459e4fd88","name":"biggie","slug":"biggie","description":null,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1407925388376,"created_by":1,"updated_at":1407925388376,"updated_by":1,"image":null,"visibility":"public"},{"id":4,"uuid":"a7e436f1-11f4-4a9c-9f68-c6b20f33205a","name":"cli","slug":"cli","description":null,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1407925388377,"created_by":1,"updated_at":1407925388377,"updated_by":1,"image":null,"visibility":"public"},{"id":5,"uuid":"df952507-c33e-43f5-846d-d9fc50071dbf","name":"tool building","slug":"tool-building","description":null,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1407925388378,"created_by":1,"updated_at":1407925388378,"updated_by":1,"image":null,"visibility":"public"},{"id":6,"uuid":"ff314e22-b80b-4dc0-8ac2-fec2312e91b4","name":"package","slug":"package","description":null,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1407925388379,"created_by":1,"updated_at":1407925388379,"updated_by":1,"image":null,"visibility":"public"}],"subscribers":[]}}]}